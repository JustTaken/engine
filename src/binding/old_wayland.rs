
 #![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_imports)]
 /* automatically generated by rust-bindgen 0.69.4 */

 pub const _STDINT_H: u32 = 1;
 pub const _FEATURES_H: u32 = 1;
 pub const _DEFAULT_SOURCE: u32 = 1;
 pub const __GLIBC_USE_ISOC2X: u32 = 0;
 pub const __USE_ISOC11: u32 = 1;
 pub const __USE_ISOC99: u32 = 1;
 pub const __USE_ISOC95: u32 = 1;
 pub const __USE_POSIX_IMPLICITLY: u32 = 1;
 pub const _POSIX_SOURCE: u32 = 1;
 pub const _POSIX_C_SOURCE: u32 = 200809;
 pub const __USE_POSIX: u32 = 1;
 pub const __USE_POSIX2: u32 = 1;
 pub const __USE_POSIX199309: u32 = 1;
 pub const __USE_POSIX199506: u32 = 1;
 pub const __USE_XOPEN2K: u32 = 1;
 pub const __USE_XOPEN2K8: u32 = 1;
 pub const _ATFILE_SOURCE: u32 = 1;
 pub const __WORDSIZE: u32 = 64;
 pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
 pub const __SYSCALL_WORDSIZE: u32 = 64;
 pub const __TIMESIZE: u32 = 64;
 pub const __USE_MISC: u32 = 1;
 pub const __USE_ATFILE: u32 = 1;
 pub const __USE_FORTIFY_LEVEL: u32 = 0;
 pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
 pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
 pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
 pub const _STDC_PREDEF_H: u32 = 1;
 pub const __STDC_IEC_559__: u32 = 1;
 pub const __STDC_IEC_60559_BFP__: u32 = 201404;
 pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
 pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
 pub const __STDC_ISO_10646__: u32 = 201706;
 pub const __GNU_LIBRARY__: u32 = 6;
 pub const __GLIBC__: u32 = 2;
 pub const __GLIBC_MINOR__: u32 = 38;
 pub const _SYS_CDEFS_H: u32 = 1;
 pub const __glibc_c99_flexarr_available: u32 = 1;
 pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
 pub const __HAVE_GENERIC_SELECTION: u32 = 1;
 pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
 pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
 pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
 pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
 pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
 pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
 pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
 pub const _BITS_TYPES_H: u32 = 1;
 pub const _BITS_TYPESIZES_H: u32 = 1;
 pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
 pub const __INO_T_MATCHES_INO64_T: u32 = 1;
 pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
 pub const __STATFS_MATCHES_STATFS64: u32 = 1;
 pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
 pub const __FD_SETSIZE: u32 = 1024;
 pub const _BITS_TIME64_H: u32 = 1;
 pub const _BITS_WCHAR_H: u32 = 1;
 pub const _BITS_STDINT_INTN_H: u32 = 1;
 pub const _BITS_STDINT_UINTN_H: u32 = 1;
 pub const INT8_MIN: i32 = -128;
 pub const INT16_MIN: i32 = -32768;
 pub const INT32_MIN: i32 = -2147483648;
 pub const INT8_MAX: u32 = 127;
 pub const INT16_MAX: u32 = 32767;
 pub const INT32_MAX: u32 = 2147483647;
 pub const UINT8_MAX: u32 = 255;
 pub const UINT16_MAX: u32 = 65535;
 pub const UINT32_MAX: u32 = 4294967295;
 pub const INT_LEAST8_MIN: i32 = -128;
 pub const INT_LEAST16_MIN: i32 = -32768;
 pub const INT_LEAST32_MIN: i32 = -2147483648;
 pub const INT_LEAST8_MAX: u32 = 127;
 pub const INT_LEAST16_MAX: u32 = 32767;
 pub const INT_LEAST32_MAX: u32 = 2147483647;
 pub const UINT_LEAST8_MAX: u32 = 255;
 pub const UINT_LEAST16_MAX: u32 = 65535;
 pub const UINT_LEAST32_MAX: u32 = 4294967295;
 pub const INT_FAST8_MIN: i32 = -128;
 pub const INT_FAST16_MIN: i64 = -9223372036854775808;
 pub const INT_FAST32_MIN: i64 = -9223372036854775808;
 pub const INT_FAST8_MAX: u32 = 127;
 pub const INT_FAST16_MAX: u64 = 9223372036854775807;
 pub const INT_FAST32_MAX: u64 = 9223372036854775807;
 pub const UINT_FAST8_MAX: u32 = 255;
 pub const UINT_FAST16_MAX: i32 = -1;
 pub const UINT_FAST32_MAX: i32 = -1;
 pub const INTPTR_MIN: i64 = -9223372036854775808;
 pub const INTPTR_MAX: u64 = 9223372036854775807;
 pub const UINTPTR_MAX: i32 = -1;
 pub const PTRDIFF_MIN: i64 = -9223372036854775808;
 pub const PTRDIFF_MAX: u64 = 9223372036854775807;
 pub const SIG_ATOMIC_MIN: i32 = -2147483648;
 pub const SIG_ATOMIC_MAX: u32 = 2147483647;
 pub const SIZE_MAX: i32 = -1;
 pub const WINT_MIN: u32 = 0;
 pub const WINT_MAX: u32 = 4294967295;
 pub const _MATH_H: u32 = 1;
 pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
 pub const __HAVE_FLOAT128: u32 = 0;
 pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
 pub const __HAVE_FLOAT64X: u32 = 1;
 pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
 pub const __HAVE_FLOAT16: u32 = 0;
 pub const __HAVE_FLOAT32: u32 = 1;
 pub const __HAVE_FLOAT64: u32 = 1;
 pub const __HAVE_FLOAT32X: u32 = 1;
 pub const __HAVE_FLOAT128X: u32 = 0;
 pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
 pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
 pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
 pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
 pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
 pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
 pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
 pub const __FP_LOGB0_IS_MIN: u32 = 1;
 pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
 pub const FP_ILOGB0: i32 = -2147483648;
 pub const FP_ILOGBNAN: i32 = -2147483648;
 pub const __MATH_DECLARING_DOUBLE: u32 = 1;
 pub const __MATH_DECLARING_FLOATN: u32 = 0;
 pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
 pub const FP_NAN: u32 = 0;
 pub const FP_INFINITE: u32 = 1;
 pub const FP_ZERO: u32 = 2;
 pub const FP_SUBNORMAL: u32 = 3;
 pub const FP_NORMAL: u32 = 4;
 pub const MATH_ERRNO: u32 = 1;
 pub const MATH_ERREXCEPT: u32 = 2;
 pub const math_errhandling: u32 = 3;
 pub const M_E: f64 = 2.718281828459045;
 pub const M_LOG2E: f64 = 1.4426950408889634;
 pub const M_LOG10E: f64 = 0.4342944819032518;
 pub const M_LN2: f64 = 0.6931471805599453;
 pub const M_LN10: f64 = 2.302585092994046;
 pub const M_PI: f64 = 3.141592653589793;
 pub const M_PI_2: f64 = 1.5707963267948966;
 pub const M_PI_4: f64 = 0.7853981633974483;
 pub const M_1_PI: f64 = 0.3183098861837907;
 pub const M_2_PI: f64 = 0.6366197723675814;
 pub const M_2_SQRTPI: f64 = 1.1283791670955126;
 pub const M_SQRT2: f64 = 1.4142135623730951;
 pub const M_SQRT1_2: f64 = 0.7071067811865476;
 pub const _INTTYPES_H: u32 = 1;
 pub const ____gwchar_t_defined: u32 = 1;
 pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
 pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
 pub const PRId8: &[u8; 2] = b"d\0";
 pub const PRId16: &[u8; 2] = b"d\0";
 pub const PRId32: &[u8; 2] = b"d\0";
 pub const PRId64: &[u8; 3] = b"ld\0";
 pub const PRIdLEAST8: &[u8; 2] = b"d\0";
 pub const PRIdLEAST16: &[u8; 2] = b"d\0";
 pub const PRIdLEAST32: &[u8; 2] = b"d\0";
 pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
 pub const PRIdFAST8: &[u8; 2] = b"d\0";
 pub const PRIdFAST16: &[u8; 3] = b"ld\0";
 pub const PRIdFAST32: &[u8; 3] = b"ld\0";
 pub const PRIdFAST64: &[u8; 3] = b"ld\0";
 pub const PRIi8: &[u8; 2] = b"i\0";
 pub const PRIi16: &[u8; 2] = b"i\0";
 pub const PRIi32: &[u8; 2] = b"i\0";
 pub const PRIi64: &[u8; 3] = b"li\0";
 pub const PRIiLEAST8: &[u8; 2] = b"i\0";
 pub const PRIiLEAST16: &[u8; 2] = b"i\0";
 pub const PRIiLEAST32: &[u8; 2] = b"i\0";
 pub const PRIiLEAST64: &[u8; 3] = b"li\0";
 pub const PRIiFAST8: &[u8; 2] = b"i\0";
 pub const PRIiFAST16: &[u8; 3] = b"li\0";
 pub const PRIiFAST32: &[u8; 3] = b"li\0";
 pub const PRIiFAST64: &[u8; 3] = b"li\0";
 pub const PRIo8: &[u8; 2] = b"o\0";
 pub const PRIo16: &[u8; 2] = b"o\0";
 pub const PRIo32: &[u8; 2] = b"o\0";
 pub const PRIo64: &[u8; 3] = b"lo\0";
 pub const PRIoLEAST8: &[u8; 2] = b"o\0";
 pub const PRIoLEAST16: &[u8; 2] = b"o\0";
 pub const PRIoLEAST32: &[u8; 2] = b"o\0";
 pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
 pub const PRIoFAST8: &[u8; 2] = b"o\0";
 pub const PRIoFAST16: &[u8; 3] = b"lo\0";
 pub const PRIoFAST32: &[u8; 3] = b"lo\0";
 pub const PRIoFAST64: &[u8; 3] = b"lo\0";
 pub const PRIu8: &[u8; 2] = b"u\0";
 pub const PRIu16: &[u8; 2] = b"u\0";
 pub const PRIu32: &[u8; 2] = b"u\0";
 pub const PRIu64: &[u8; 3] = b"lu\0";
 pub const PRIuLEAST8: &[u8; 2] = b"u\0";
 pub const PRIuLEAST16: &[u8; 2] = b"u\0";
 pub const PRIuLEAST32: &[u8; 2] = b"u\0";
 pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
 pub const PRIuFAST8: &[u8; 2] = b"u\0";
 pub const PRIuFAST16: &[u8; 3] = b"lu\0";
 pub const PRIuFAST32: &[u8; 3] = b"lu\0";
 pub const PRIuFAST64: &[u8; 3] = b"lu\0";
 pub const PRIx8: &[u8; 2] = b"x\0";
 pub const PRIx16: &[u8; 2] = b"x\0";
 pub const PRIx32: &[u8; 2] = b"x\0";
 pub const PRIx64: &[u8; 3] = b"lx\0";
 pub const PRIxLEAST8: &[u8; 2] = b"x\0";
 pub const PRIxLEAST16: &[u8; 2] = b"x\0";
 pub const PRIxLEAST32: &[u8; 2] = b"x\0";
 pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
 pub const PRIxFAST8: &[u8; 2] = b"x\0";
 pub const PRIxFAST16: &[u8; 3] = b"lx\0";
 pub const PRIxFAST32: &[u8; 3] = b"lx\0";
 pub const PRIxFAST64: &[u8; 3] = b"lx\0";
 pub const PRIX8: &[u8; 2] = b"X\0";
 pub const PRIX16: &[u8; 2] = b"X\0";
 pub const PRIX32: &[u8; 2] = b"X\0";
 pub const PRIX64: &[u8; 3] = b"lX\0";
 pub const PRIXLEAST8: &[u8; 2] = b"X\0";
 pub const PRIXLEAST16: &[u8; 2] = b"X\0";
 pub const PRIXLEAST32: &[u8; 2] = b"X\0";
 pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
 pub const PRIXFAST8: &[u8; 2] = b"X\0";
 pub const PRIXFAST16: &[u8; 3] = b"lX\0";
 pub const PRIXFAST32: &[u8; 3] = b"lX\0";
 pub const PRIXFAST64: &[u8; 3] = b"lX\0";
 pub const PRIdMAX: &[u8; 3] = b"ld\0";
 pub const PRIiMAX: &[u8; 3] = b"li\0";
 pub const PRIoMAX: &[u8; 3] = b"lo\0";
 pub const PRIuMAX: &[u8; 3] = b"lu\0";
 pub const PRIxMAX: &[u8; 3] = b"lx\0";
 pub const PRIXMAX: &[u8; 3] = b"lX\0";
 pub const PRIdPTR: &[u8; 3] = b"ld\0";
 pub const PRIiPTR: &[u8; 3] = b"li\0";
 pub const PRIoPTR: &[u8; 3] = b"lo\0";
 pub const PRIuPTR: &[u8; 3] = b"lu\0";
 pub const PRIxPTR: &[u8; 3] = b"lx\0";
 pub const PRIXPTR: &[u8; 3] = b"lX\0";
 pub const SCNd8: &[u8; 4] = b"hhd\0";
 pub const SCNd16: &[u8; 3] = b"hd\0";
 pub const SCNd32: &[u8; 2] = b"d\0";
 pub const SCNd64: &[u8; 3] = b"ld\0";
 pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
 pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
 pub const SCNdLEAST32: &[u8; 2] = b"d\0";
 pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
 pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
 pub const SCNdFAST16: &[u8; 3] = b"ld\0";
 pub const SCNdFAST32: &[u8; 3] = b"ld\0";
 pub const SCNdFAST64: &[u8; 3] = b"ld\0";
 pub const SCNi8: &[u8; 4] = b"hhi\0";
 pub const SCNi16: &[u8; 3] = b"hi\0";
 pub const SCNi32: &[u8; 2] = b"i\0";
 pub const SCNi64: &[u8; 3] = b"li\0";
 pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
 pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
 pub const SCNiLEAST32: &[u8; 2] = b"i\0";
 pub const SCNiLEAST64: &[u8; 3] = b"li\0";
 pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
 pub const SCNiFAST16: &[u8; 3] = b"li\0";
 pub const SCNiFAST32: &[u8; 3] = b"li\0";
 pub const SCNiFAST64: &[u8; 3] = b"li\0";
 pub const SCNu8: &[u8; 4] = b"hhu\0";
 pub const SCNu16: &[u8; 3] = b"hu\0";
 pub const SCNu32: &[u8; 2] = b"u\0";
 pub const SCNu64: &[u8; 3] = b"lu\0";
 pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
 pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
 pub const SCNuLEAST32: &[u8; 2] = b"u\0";
 pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
 pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
 pub const SCNuFAST16: &[u8; 3] = b"lu\0";
 pub const SCNuFAST32: &[u8; 3] = b"lu\0";
 pub const SCNuFAST64: &[u8; 3] = b"lu\0";
 pub const SCNo8: &[u8; 4] = b"hho\0";
 pub const SCNo16: &[u8; 3] = b"ho\0";
 pub const SCNo32: &[u8; 2] = b"o\0";
 pub const SCNo64: &[u8; 3] = b"lo\0";
 pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
 pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
 pub const SCNoLEAST32: &[u8; 2] = b"o\0";
 pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
 pub const SCNoFAST8: &[u8; 4] = b"hho\0";
 pub const SCNoFAST16: &[u8; 3] = b"lo\0";
 pub const SCNoFAST32: &[u8; 3] = b"lo\0";
 pub const SCNoFAST64: &[u8; 3] = b"lo\0";
 pub const SCNx8: &[u8; 4] = b"hhx\0";
 pub const SCNx16: &[u8; 3] = b"hx\0";
 pub const SCNx32: &[u8; 2] = b"x\0";
 pub const SCNx64: &[u8; 3] = b"lx\0";
 pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
 pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
 pub const SCNxLEAST32: &[u8; 2] = b"x\0";
 pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
 pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
 pub const SCNxFAST16: &[u8; 3] = b"lx\0";
 pub const SCNxFAST32: &[u8; 3] = b"lx\0";
 pub const SCNxFAST64: &[u8; 3] = b"lx\0";
 pub const SCNdMAX: &[u8; 3] = b"ld\0";
 pub const SCNiMAX: &[u8; 3] = b"li\0";
 pub const SCNoMAX: &[u8; 3] = b"lo\0";
 pub const SCNuMAX: &[u8; 3] = b"lu\0";
 pub const SCNxMAX: &[u8; 3] = b"lx\0";
 pub const SCNdPTR: &[u8; 3] = b"ld\0";
 pub const SCNiPTR: &[u8; 3] = b"li\0";
 pub const SCNoPTR: &[u8; 3] = b"lo\0";
 pub const SCNuPTR: &[u8; 3] = b"lu\0";
 pub const SCNxPTR: &[u8; 3] = b"lx\0";
 pub const WAYLAND_VERSION_MAJOR: u32 = 1;
 pub const WAYLAND_VERSION_MINOR: u32 = 22;
 pub const WAYLAND_VERSION_MICRO: u32 = 0;
 pub const WAYLAND_VERSION: &[u8; 7] = b"1.22.0\0";
 pub const WL_MARSHAL_FLAG_DESTROY: u32 = 1;
 pub const WL_DISPLAY_SYNC: u32 = 0;
pub const WL_DISPLAY_GET_REGISTRY: u32 = 1;
 pub const WL_DISPLAY_ERROR_SINCE_VERSION: u32 = 1;
 pub const WL_DISPLAY_DELETE_ID_SINCE_VERSION: u32 = 1;
 pub const WL_DISPLAY_SYNC_SINCE_VERSION: u32 = 1;
 pub const WL_DISPLAY_GET_REGISTRY_SINCE_VERSION: u32 = 1;
pub const WL_REGISTRY_BIND: u32 = 0;
 pub const WL_REGISTRY_GLOBAL_SINCE_VERSION: u32 = 1;
 pub const WL_REGISTRY_GLOBAL_REMOVE_SINCE_VERSION: u32 = 1;
 pub const WL_REGISTRY_BIND_SINCE_VERSION: u32 = 1;
 pub const WL_CALLBACK_DONE_SINCE_VERSION: u32 = 1;
pub const WL_COMPOSITOR_CREATE_SURFACE: u32 = 0;
 pub const WL_COMPOSITOR_CREATE_REGION: u32 = 1;
 pub const WL_COMPOSITOR_CREATE_SURFACE_SINCE_VERSION: u32 = 1;
 pub const WL_COMPOSITOR_CREATE_REGION_SINCE_VERSION: u32 = 1;
 pub const WL_SHM_POOL_CREATE_BUFFER: u32 = 0;
 pub const WL_SHM_POOL_DESTROY: u32 = 1;
 pub const WL_SHM_POOL_RESIZE: u32 = 2;
 pub const WL_SHM_POOL_CREATE_BUFFER_SINCE_VERSION: u32 = 1;
 pub const WL_SHM_POOL_DESTROY_SINCE_VERSION: u32 = 1;
 pub const WL_SHM_POOL_RESIZE_SINCE_VERSION: u32 = 1;
 pub const WL_SHM_CREATE_POOL: u32 = 0;
 pub const WL_SHM_FORMAT_SINCE_VERSION: u32 = 1;
 pub const WL_SHM_CREATE_POOL_SINCE_VERSION: u32 = 1;
 pub const WL_BUFFER_DESTROY: u32 = 0;
 pub const WL_BUFFER_RELEASE_SINCE_VERSION: u32 = 1;
 pub const WL_BUFFER_DESTROY_SINCE_VERSION: u32 = 1;
 pub const WL_DATA_OFFER_ACCEPT: u32 = 0;
 pub const WL_DATA_OFFER_RECEIVE: u32 = 1;
 pub const WL_DATA_OFFER_DESTROY: u32 = 2;
 pub const WL_DATA_OFFER_FINISH: u32 = 3;
 pub const WL_DATA_OFFER_SET_ACTIONS: u32 = 4;
 pub const WL_DATA_OFFER_OFFER_SINCE_VERSION: u32 = 1;
 pub const WL_DATA_OFFER_SOURCE_ACTIONS_SINCE_VERSION: u32 = 3;
 pub const WL_DATA_OFFER_ACTION_SINCE_VERSION: u32 = 3;
 pub const WL_DATA_OFFER_ACCEPT_SINCE_VERSION: u32 = 1;
 pub const WL_DATA_OFFER_RECEIVE_SINCE_VERSION: u32 = 1;
 pub const WL_DATA_OFFER_DESTROY_SINCE_VERSION: u32 = 1;
 pub const WL_DATA_OFFER_FINISH_SINCE_VERSION: u32 = 3;
 pub const WL_DATA_OFFER_SET_ACTIONS_SINCE_VERSION: u32 = 3;
 pub const WL_DATA_SOURCE_OFFER: u32 = 0;
 pub const WL_DATA_SOURCE_DESTROY: u32 = 1;
 pub const WL_DATA_SOURCE_SET_ACTIONS: u32 = 2;
 pub const WL_DATA_SOURCE_TARGET_SINCE_VERSION: u32 = 1;
 pub const WL_DATA_SOURCE_SEND_SINCE_VERSION: u32 = 1;
 pub const WL_DATA_SOURCE_CANCELLED_SINCE_VERSION: u32 = 1;
 pub const WL_DATA_SOURCE_DND_DROP_PERFORMED_SINCE_VERSION: u32 = 3;
 pub const WL_DATA_SOURCE_DND_FINISHED_SINCE_VERSION: u32 = 3;
 pub const WL_DATA_SOURCE_ACTION_SINCE_VERSION: u32 = 3;
 pub const WL_DATA_SOURCE_OFFER_SINCE_VERSION: u32 = 1;
 pub const WL_DATA_SOURCE_DESTROY_SINCE_VERSION: u32 = 1;
 pub const WL_DATA_SOURCE_SET_ACTIONS_SINCE_VERSION: u32 = 3;
 pub const WL_DATA_DEVICE_START_DRAG: u32 = 0;
 pub const WL_DATA_DEVICE_SET_SELECTION: u32 = 1;
 pub const WL_DATA_DEVICE_RELEASE: u32 = 2;
 pub const WL_DATA_DEVICE_DATA_OFFER_SINCE_VERSION: u32 = 1;
 pub const WL_DATA_DEVICE_ENTER_SINCE_VERSION: u32 = 1;
 pub const WL_DATA_DEVICE_LEAVE_SINCE_VERSION: u32 = 1;
 pub const WL_DATA_DEVICE_MOTION_SINCE_VERSION: u32 = 1;
 pub const WL_DATA_DEVICE_DROP_SINCE_VERSION: u32 = 1;
 pub const WL_DATA_DEVICE_SELECTION_SINCE_VERSION: u32 = 1;
 pub const WL_DATA_DEVICE_START_DRAG_SINCE_VERSION: u32 = 1;
 pub const WL_DATA_DEVICE_SET_SELECTION_SINCE_VERSION: u32 = 1;
 pub const WL_DATA_DEVICE_RELEASE_SINCE_VERSION: u32 = 2;
 pub const WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE: u32 = 0;
 pub const WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE: u32 = 1;
 pub const WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE_SINCE_VERSION: u32 = 1;
 pub const WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE_SINCE_VERSION: u32 = 1;
 pub const WL_SHELL_GET_SHELL_SURFACE: u32 = 0;
 pub const WL_SHELL_GET_SHELL_SURFACE_SINCE_VERSION: u32 = 1;
 pub const WL_SHELL_SURFACE_PONG: u32 = 0;
 pub const WL_SHELL_SURFACE_MOVE: u32 = 1;
 pub const WL_SHELL_SURFACE_RESIZE: u32 = 2;
 pub const WL_SHELL_SURFACE_SET_TOPLEVEL: u32 = 3;
 pub const WL_SHELL_SURFACE_SET_TRANSIENT: u32 = 4;
 pub const WL_SHELL_SURFACE_SET_FULLSCREEN: u32 = 5;
 pub const WL_SHELL_SURFACE_SET_POPUP: u32 = 6;
 pub const WL_SHELL_SURFACE_SET_MAXIMIZED: u32 = 7;
 pub const WL_SHELL_SURFACE_SET_TITLE: u32 = 8;
 pub const WL_SHELL_SURFACE_SET_CLASS: u32 = 9;
 pub const WL_SHELL_SURFACE_PING_SINCE_VERSION: u32 = 1;
 pub const WL_SHELL_SURFACE_CONFIGURE_SINCE_VERSION: u32 = 1;
 pub const WL_SHELL_SURFACE_POPUP_DONE_SINCE_VERSION: u32 = 1;
 pub const WL_SHELL_SURFACE_PONG_SINCE_VERSION: u32 = 1;
 pub const WL_SHELL_SURFACE_MOVE_SINCE_VERSION: u32 = 1;
 pub const WL_SHELL_SURFACE_RESIZE_SINCE_VERSION: u32 = 1;
 pub const WL_SHELL_SURFACE_SET_TOPLEVEL_SINCE_VERSION: u32 = 1;
 pub const WL_SHELL_SURFACE_SET_TRANSIENT_SINCE_VERSION: u32 = 1;
 pub const WL_SHELL_SURFACE_SET_FULLSCREEN_SINCE_VERSION: u32 = 1;
 pub const WL_SHELL_SURFACE_SET_POPUP_SINCE_VERSION: u32 = 1;
 pub const WL_SHELL_SURFACE_SET_MAXIMIZED_SINCE_VERSION: u32 = 1;
 pub const WL_SHELL_SURFACE_SET_TITLE_SINCE_VERSION: u32 = 1;
 pub const WL_SHELL_SURFACE_SET_CLASS_SINCE_VERSION: u32 = 1;
 pub const WL_SURFACE_DESTROY: u32 = 0;
 pub const WL_SURFACE_ATTACH: u32 = 1;
 pub const WL_SURFACE_DAMAGE: u32 = 2;
 pub const WL_SURFACE_FRAME: u32 = 3;
 pub const WL_SURFACE_SET_OPAQUE_REGION: u32 = 4;
 pub const WL_SURFACE_SET_INPUT_REGION: u32 = 5;
pub const WL_SURFACE_COMMIT: u32 = 6;
 pub const WL_SURFACE_SET_BUFFER_TRANSFORM: u32 = 7;
 pub const WL_SURFACE_SET_BUFFER_SCALE: u32 = 8;
 pub const WL_SURFACE_DAMAGE_BUFFER: u32 = 9;
 pub const WL_SURFACE_OFFSET: u32 = 10;
 pub const WL_SURFACE_ENTER_SINCE_VERSION: u32 = 1;
 pub const WL_SURFACE_LEAVE_SINCE_VERSION: u32 = 1;
 pub const WL_SURFACE_PREFERRED_BUFFER_SCALE_SINCE_VERSION: u32 = 6;
 pub const WL_SURFACE_PREFERRED_BUFFER_TRANSFORM_SINCE_VERSION: u32 = 6;
 pub const WL_SURFACE_DESTROY_SINCE_VERSION: u32 = 1;
 pub const WL_SURFACE_ATTACH_SINCE_VERSION: u32 = 1;
 pub const WL_SURFACE_DAMAGE_SINCE_VERSION: u32 = 1;
 pub const WL_SURFACE_FRAME_SINCE_VERSION: u32 = 1;
 pub const WL_SURFACE_SET_OPAQUE_REGION_SINCE_VERSION: u32 = 1;
 pub const WL_SURFACE_SET_INPUT_REGION_SINCE_VERSION: u32 = 1;
 pub const WL_SURFACE_COMMIT_SINCE_VERSION: u32 = 1;
 pub const WL_SURFACE_SET_BUFFER_TRANSFORM_SINCE_VERSION: u32 = 2;
 pub const WL_SURFACE_SET_BUFFER_SCALE_SINCE_VERSION: u32 = 3;
 pub const WL_SURFACE_DAMAGE_BUFFER_SINCE_VERSION: u32 = 4;
 pub const WL_SURFACE_OFFSET_SINCE_VERSION: u32 = 5;
 pub const WL_SEAT_GET_POINTER: u32 = 0;
 pub const WL_SEAT_GET_KEYBOARD: u32 = 1;
 pub const WL_SEAT_GET_TOUCH: u32 = 2;
 pub const WL_SEAT_RELEASE: u32 = 3;
 pub const WL_SEAT_CAPABILITIES_SINCE_VERSION: u32 = 1;
 pub const WL_SEAT_NAME_SINCE_VERSION: u32 = 2;
 pub const WL_SEAT_GET_POINTER_SINCE_VERSION: u32 = 1;
 pub const WL_SEAT_GET_KEYBOARD_SINCE_VERSION: u32 = 1;
 pub const WL_SEAT_GET_TOUCH_SINCE_VERSION: u32 = 1;
 pub const WL_SEAT_RELEASE_SINCE_VERSION: u32 = 5;
 pub const WL_POINTER_AXIS_SOURCE_WHEEL_TILT_SINCE_VERSION: u32 = 6;
 pub const WL_POINTER_SET_CURSOR: u32 = 0;
 pub const WL_POINTER_RELEASE: u32 = 1;
 pub const WL_POINTER_ENTER_SINCE_VERSION: u32 = 1;
 pub const WL_POINTER_LEAVE_SINCE_VERSION: u32 = 1;
 pub const WL_POINTER_MOTION_SINCE_VERSION: u32 = 1;
 pub const WL_POINTER_BUTTON_SINCE_VERSION: u32 = 1;
 pub const WL_POINTER_AXIS_SINCE_VERSION: u32 = 1;
 pub const WL_POINTER_FRAME_SINCE_VERSION: u32 = 5;
 pub const WL_POINTER_AXIS_SOURCE_SINCE_VERSION: u32 = 5;
 pub const WL_POINTER_AXIS_STOP_SINCE_VERSION: u32 = 5;
 pub const WL_POINTER_AXIS_DISCRETE_SINCE_VERSION: u32 = 5;
 pub const WL_POINTER_AXIS_VALUE120_SINCE_VERSION: u32 = 8;
 pub const WL_POINTER_AXIS_RELATIVE_DIRECTION_SINCE_VERSION: u32 = 9;
 pub const WL_POINTER_SET_CURSOR_SINCE_VERSION: u32 = 1;
 pub const WL_POINTER_RELEASE_SINCE_VERSION: u32 = 3;
 pub const WL_KEYBOARD_RELEASE: u32 = 0;
 pub const WL_KEYBOARD_KEYMAP_SINCE_VERSION: u32 = 1;
 pub const WL_KEYBOARD_ENTER_SINCE_VERSION: u32 = 1;
 pub const WL_KEYBOARD_LEAVE_SINCE_VERSION: u32 = 1;
 pub const WL_KEYBOARD_KEY_SINCE_VERSION: u32 = 1;
 pub const WL_KEYBOARD_MODIFIERS_SINCE_VERSION: u32 = 1;
 pub const WL_KEYBOARD_REPEAT_INFO_SINCE_VERSION: u32 = 4;
 pub const WL_KEYBOARD_RELEASE_SINCE_VERSION: u32 = 3;
 pub const WL_TOUCH_RELEASE: u32 = 0;
 pub const WL_TOUCH_DOWN_SINCE_VERSION: u32 = 1;
 pub const WL_TOUCH_UP_SINCE_VERSION: u32 = 1;
 pub const WL_TOUCH_MOTION_SINCE_VERSION: u32 = 1;
 pub const WL_TOUCH_FRAME_SINCE_VERSION: u32 = 1;
 pub const WL_TOUCH_CANCEL_SINCE_VERSION: u32 = 1;
 pub const WL_TOUCH_SHAPE_SINCE_VERSION: u32 = 6;
 pub const WL_TOUCH_ORIENTATION_SINCE_VERSION: u32 = 6;
 pub const WL_TOUCH_RELEASE_SINCE_VERSION: u32 = 3;
 pub const WL_OUTPUT_RELEASE: u32 = 0;
 pub const WL_OUTPUT_GEOMETRY_SINCE_VERSION: u32 = 1;
 pub const WL_OUTPUT_MODE_SINCE_VERSION: u32 = 1;
 pub const WL_OUTPUT_DONE_SINCE_VERSION: u32 = 2;
 pub const WL_OUTPUT_SCALE_SINCE_VERSION: u32 = 2;
 pub const WL_OUTPUT_NAME_SINCE_VERSION: u32 = 4;
 pub const WL_OUTPUT_DESCRIPTION_SINCE_VERSION: u32 = 4;
 pub const WL_OUTPUT_RELEASE_SINCE_VERSION: u32 = 3;
 pub const WL_REGION_DESTROY: u32 = 0;
 pub const WL_REGION_ADD: u32 = 1;
 pub const WL_REGION_SUBTRACT: u32 = 2;
 pub const WL_REGION_DESTROY_SINCE_VERSION: u32 = 1;
 pub const WL_REGION_ADD_SINCE_VERSION: u32 = 1;
 pub const WL_REGION_SUBTRACT_SINCE_VERSION: u32 = 1;
 pub const WL_SUBCOMPOSITOR_DESTROY: u32 = 0;
 pub const WL_SUBCOMPOSITOR_GET_SUBSURFACE: u32 = 1;
 pub const WL_SUBCOMPOSITOR_DESTROY_SINCE_VERSION: u32 = 1;
 pub const WL_SUBCOMPOSITOR_GET_SUBSURFACE_SINCE_VERSION: u32 = 1;
 pub const WL_SUBSURFACE_DESTROY: u32 = 0;
 pub const WL_SUBSURFACE_SET_POSITION: u32 = 1;
 pub const WL_SUBSURFACE_PLACE_ABOVE: u32 = 2;
 pub const WL_SUBSURFACE_PLACE_BELOW: u32 = 3;
 pub const WL_SUBSURFACE_SET_SYNC: u32 = 4;
 pub const WL_SUBSURFACE_SET_DESYNC: u32 = 5;
 pub const WL_SUBSURFACE_DESTROY_SINCE_VERSION: u32 = 1;
 pub const WL_SUBSURFACE_SET_POSITION_SINCE_VERSION: u32 = 1;
 pub const WL_SUBSURFACE_PLACE_ABOVE_SINCE_VERSION: u32 = 1;
 pub const WL_SUBSURFACE_PLACE_BELOW_SINCE_VERSION: u32 = 1;
 pub const WL_SUBSURFACE_SET_SYNC_SINCE_VERSION: u32 = 1;
 pub const WL_SUBSURFACE_SET_DESYNC_SINCE_VERSION: u32 = 1;
 pub const XDG_WM_BASE_DESTROY: u32 = 0;
 pub const XDG_WM_BASE_CREATE_POSITIONER: u32 = 1;
pub const XDG_WM_BASE_GET_XDG_SURFACE: u32 = 2;
pub const XDG_WM_BASE_PONG: u32 = 3;
 pub const XDG_WM_BASE_PING_SINCE_VERSION: u32 = 1;
 pub const XDG_WM_BASE_DESTROY_SINCE_VERSION: u32 = 1;
 pub const XDG_WM_BASE_CREATE_POSITIONER_SINCE_VERSION: u32 = 1;
 pub const XDG_WM_BASE_GET_XDG_SURFACE_SINCE_VERSION: u32 = 1;
 pub const XDG_WM_BASE_PONG_SINCE_VERSION: u32 = 1;
 pub const XDG_POSITIONER_DESTROY: u32 = 0;
 pub const XDG_POSITIONER_SET_SIZE: u32 = 1;
 pub const XDG_POSITIONER_SET_ANCHOR_RECT: u32 = 2;
 pub const XDG_POSITIONER_SET_ANCHOR: u32 = 3;
 pub const XDG_POSITIONER_SET_GRAVITY: u32 = 4;
 pub const XDG_POSITIONER_SET_CONSTRAINT_ADJUSTMENT: u32 = 5;
 pub const XDG_POSITIONER_SET_OFFSET: u32 = 6;
 pub const XDG_POSITIONER_SET_REACTIVE: u32 = 7;
 pub const XDG_POSITIONER_SET_PARENT_SIZE: u32 = 8;
 pub const XDG_POSITIONER_SET_PARENT_CONFIGURE: u32 = 9;
 pub const XDG_POSITIONER_DESTROY_SINCE_VERSION: u32 = 1;
 pub const XDG_POSITIONER_SET_SIZE_SINCE_VERSION: u32 = 1;
 pub const XDG_POSITIONER_SET_ANCHOR_RECT_SINCE_VERSION: u32 = 1;
 pub const XDG_POSITIONER_SET_ANCHOR_SINCE_VERSION: u32 = 1;
 pub const XDG_POSITIONER_SET_GRAVITY_SINCE_VERSION: u32 = 1;
 pub const XDG_POSITIONER_SET_CONSTRAINT_ADJUSTMENT_SINCE_VERSION: u32 = 1;
 pub const XDG_POSITIONER_SET_OFFSET_SINCE_VERSION: u32 = 1;
 pub const XDG_POSITIONER_SET_REACTIVE_SINCE_VERSION: u32 = 3;
 pub const XDG_POSITIONER_SET_PARENT_SIZE_SINCE_VERSION: u32 = 3;
 pub const XDG_POSITIONER_SET_PARENT_CONFIGURE_SINCE_VERSION: u32 = 3;
 pub const XDG_SURFACE_DESTROY: u32 = 0;
pub const XDG_SURFACE_GET_TOPLEVEL: u32 = 1;
 pub const XDG_SURFACE_GET_POPUP: u32 = 2;
 pub const XDG_SURFACE_SET_WINDOW_GEOMETRY: u32 = 3;
pub const XDG_SURFACE_ACK_CONFIGURE: u32 = 4;
 pub const XDG_SURFACE_CONFIGURE_SINCE_VERSION: u32 = 1;
 pub const XDG_SURFACE_DESTROY_SINCE_VERSION: u32 = 1;
 pub const XDG_SURFACE_GET_TOPLEVEL_SINCE_VERSION: u32 = 1;
 pub const XDG_SURFACE_GET_POPUP_SINCE_VERSION: u32 = 1;
 pub const XDG_SURFACE_SET_WINDOW_GEOMETRY_SINCE_VERSION: u32 = 1;
 pub const XDG_SURFACE_ACK_CONFIGURE_SINCE_VERSION: u32 = 1;
 pub const XDG_TOPLEVEL_STATE_TILED_LEFT_SINCE_VERSION: u32 = 2;
 pub const XDG_TOPLEVEL_STATE_TILED_RIGHT_SINCE_VERSION: u32 = 2;
 pub const XDG_TOPLEVEL_STATE_TILED_TOP_SINCE_VERSION: u32 = 2;
 pub const XDG_TOPLEVEL_STATE_TILED_BOTTOM_SINCE_VERSION: u32 = 2;
 pub const XDG_TOPLEVEL_STATE_SUSPENDED_SINCE_VERSION: u32 = 6;
 pub const XDG_TOPLEVEL_DESTROY: u32 = 0;
 pub const XDG_TOPLEVEL_SET_PARENT: u32 = 1;
pub const XDG_TOPLEVEL_SET_TITLE: u32 = 2;
pub const XDG_TOPLEVEL_SET_APP_ID: u32 = 3;
 pub const XDG_TOPLEVEL_SHOW_WINDOW_MENU: u32 = 4;
 pub const XDG_TOPLEVEL_MOVE: u32 = 5;
 pub const XDG_TOPLEVEL_RESIZE: u32 = 6;
 pub const XDG_TOPLEVEL_SET_MAX_SIZE: u32 = 7;
 pub const XDG_TOPLEVEL_SET_MIN_SIZE: u32 = 8;
 pub const XDG_TOPLEVEL_SET_MAXIMIZED: u32 = 9;
 pub const XDG_TOPLEVEL_UNSET_MAXIMIZED: u32 = 10;
 pub const XDG_TOPLEVEL_SET_FULLSCREEN: u32 = 11;
 pub const XDG_TOPLEVEL_UNSET_FULLSCREEN: u32 = 12;
 pub const XDG_TOPLEVEL_SET_MINIMIZED: u32 = 13;
 pub const XDG_TOPLEVEL_CONFIGURE_SINCE_VERSION: u32 = 1;
 pub const XDG_TOPLEVEL_CLOSE_SINCE_VERSION: u32 = 1;
 pub const XDG_TOPLEVEL_CONFIGURE_BOUNDS_SINCE_VERSION: u32 = 4;
 pub const XDG_TOPLEVEL_WM_CAPABILITIES_SINCE_VERSION: u32 = 5;
 pub const XDG_TOPLEVEL_DESTROY_SINCE_VERSION: u32 = 1;
 pub const XDG_TOPLEVEL_SET_PARENT_SINCE_VERSION: u32 = 1;
 pub const XDG_TOPLEVEL_SET_TITLE_SINCE_VERSION: u32 = 1;
 pub const XDG_TOPLEVEL_SET_APP_ID_SINCE_VERSION: u32 = 1;
 pub const XDG_TOPLEVEL_SHOW_WINDOW_MENU_SINCE_VERSION: u32 = 1;
 pub const XDG_TOPLEVEL_MOVE_SINCE_VERSION: u32 = 1;
 pub const XDG_TOPLEVEL_RESIZE_SINCE_VERSION: u32 = 1;
 pub const XDG_TOPLEVEL_SET_MAX_SIZE_SINCE_VERSION: u32 = 1;
 pub const XDG_TOPLEVEL_SET_MIN_SIZE_SINCE_VERSION: u32 = 1;
 pub const XDG_TOPLEVEL_SET_MAXIMIZED_SINCE_VERSION: u32 = 1;
 pub const XDG_TOPLEVEL_UNSET_MAXIMIZED_SINCE_VERSION: u32 = 1;
 pub const XDG_TOPLEVEL_SET_FULLSCREEN_SINCE_VERSION: u32 = 1;
 pub const XDG_TOPLEVEL_UNSET_FULLSCREEN_SINCE_VERSION: u32 = 1;
 pub const XDG_TOPLEVEL_SET_MINIMIZED_SINCE_VERSION: u32 = 1;
 pub const XDG_POPUP_DESTROY: u32 = 0;
 pub const XDG_POPUP_GRAB: u32 = 1;
 pub const XDG_POPUP_REPOSITION: u32 = 2;
 pub const XDG_POPUP_CONFIGURE_SINCE_VERSION: u32 = 1;
 pub const XDG_POPUP_POPUP_DONE_SINCE_VERSION: u32 = 1;
 pub const XDG_POPUP_REPOSITIONED_SINCE_VERSION: u32 = 3;
 pub const XDG_POPUP_DESTROY_SINCE_VERSION: u32 = 1;
 pub const XDG_POPUP_GRAB_SINCE_VERSION: u32 = 1;
 pub const XDG_POPUP_REPOSITION_SINCE_VERSION: u32 = 3;
 pub type __u_char = ::std::os::raw::c_uchar;
 pub type __u_short = ::std::os::raw::c_ushort;
 pub type __u_int = ::std::os::raw::c_uint;
 pub type __u_long = ::std::os::raw::c_ulong;
 pub type __int8_t = ::std::os::raw::c_schar;
 pub type __uint8_t = ::std::os::raw::c_uchar;
 pub type __int16_t = ::std::os::raw::c_short;
 pub type __uint16_t = ::std::os::raw::c_ushort;
 pub type __int32_t = ::std::os::raw::c_int;
 pub type __uint32_t = ::std::os::raw::c_uint;
 pub type __int64_t = ::std::os::raw::c_long;
 pub type __uint64_t = ::std::os::raw::c_ulong;
 pub type __int_least8_t = __int8_t;
 pub type __uint_least8_t = __uint8_t;
 pub type __int_least16_t = __int16_t;
 pub type __uint_least16_t = __uint16_t;
 pub type __int_least32_t = __int32_t;
 pub type __uint_least32_t = __uint32_t;
 pub type __int_least64_t = __int64_t;
 pub type __uint_least64_t = __uint64_t;
 pub type __quad_t = ::std::os::raw::c_long;
 pub type __u_quad_t = ::std::os::raw::c_ulong;
 pub type __intmax_t = ::std::os::raw::c_long;
 pub type __uintmax_t = ::std::os::raw::c_ulong;
 pub type __dev_t = ::std::os::raw::c_ulong;
 pub type __uid_t = ::std::os::raw::c_uint;
 pub type __gid_t = ::std::os::raw::c_uint;
 pub type __ino_t = ::std::os::raw::c_ulong;
 pub type __ino64_t = ::std::os::raw::c_ulong;
 pub type __mode_t = ::std::os::raw::c_uint;
 pub type __nlink_t = ::std::os::raw::c_ulong;
 pub type __off_t = ::std::os::raw::c_long;
 pub type __off64_t = ::std::os::raw::c_long;
 pub type __pid_t = ::std::os::raw::c_int;
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct __fsid_t {
     pub __val: [::std::os::raw::c_int; 2usize],
 }
 #[test]
 fn bindgen_test_layout___fsid_t() {
     const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<__fsid_t>(),
         8usize,
         concat!("Size of: ", stringify!(__fsid_t))
     );
     assert_eq!(
         ::std::mem::align_of::<__fsid_t>(),
         4usize,
         concat!("Alignment of ", stringify!(__fsid_t))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(__fsid_t),
             "::",
             stringify!(__val)
         )
     );
 }
 pub type __clock_t = ::std::os::raw::c_long;
 pub type __rlim_t = ::std::os::raw::c_ulong;
 pub type __rlim64_t = ::std::os::raw::c_ulong;
 pub type __id_t = ::std::os::raw::c_uint;
 pub type __time_t = ::std::os::raw::c_long;
 pub type __useconds_t = ::std::os::raw::c_uint;
 pub type __suseconds_t = ::std::os::raw::c_long;
 pub type __suseconds64_t = ::std::os::raw::c_long;
 pub type __daddr_t = ::std::os::raw::c_int;
 pub type __key_t = ::std::os::raw::c_int;
 pub type __clockid_t = ::std::os::raw::c_int;
 pub type __timer_t = *mut ::std::os::raw::c_void;
 pub type __blksize_t = ::std::os::raw::c_long;
 pub type __blkcnt_t = ::std::os::raw::c_long;
 pub type __blkcnt64_t = ::std::os::raw::c_long;
 pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
 pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
 pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
 pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
 pub type __fsword_t = ::std::os::raw::c_long;
 pub type __ssize_t = ::std::os::raw::c_long;
 pub type __syscall_slong_t = ::std::os::raw::c_long;
 pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
 pub type __loff_t = __off64_t;
 pub type __caddr_t = *mut ::std::os::raw::c_char;
 pub type __intptr_t = ::std::os::raw::c_long;
 pub type __socklen_t = ::std::os::raw::c_uint;
 pub type __sig_atomic_t = ::std::os::raw::c_int;
 pub type int_least8_t = __int_least8_t;
 pub type int_least16_t = __int_least16_t;
 pub type int_least32_t = __int_least32_t;
 pub type int_least64_t = __int_least64_t;
 pub type uint_least8_t = __uint_least8_t;
 pub type uint_least16_t = __uint_least16_t;
 pub type uint_least32_t = __uint_least32_t;
 pub type uint_least64_t = __uint_least64_t;
 pub type int_fast8_t = ::std::os::raw::c_schar;
 pub type int_fast16_t = ::std::os::raw::c_long;
 pub type int_fast32_t = ::std::os::raw::c_long;
 pub type int_fast64_t = ::std::os::raw::c_long;
 pub type uint_fast8_t = ::std::os::raw::c_uchar;
 pub type uint_fast16_t = ::std::os::raw::c_ulong;
 pub type uint_fast32_t = ::std::os::raw::c_ulong;
 pub type uint_fast64_t = ::std::os::raw::c_ulong;
 pub type intmax_t = __intmax_t;
 pub type uintmax_t = __uintmax_t;
 pub type wchar_t = ::std::os::raw::c_int;
 #[repr(C)]
 #[repr(align(16))]
 #[derive(Debug, Copy, Clone)]
 pub struct max_align_t {
     pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
     pub __bindgen_padding_0: u64,
     pub __clang_max_align_nonce2: u128,
 }
 #[test]
 fn bindgen_test_layout_max_align_t() {
     const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<max_align_t>(),
         32usize,
         concat!("Size of: ", stringify!(max_align_t))
     );
     assert_eq!(
         ::std::mem::align_of::<max_align_t>(),
         16usize,
         concat!("Alignment of ", stringify!(max_align_t))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(max_align_t),
             "::",
             stringify!(__clang_max_align_nonce1)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
         16usize,
         concat!(
             "Offset of field: ",
             stringify!(max_align_t),
             "::",
             stringify!(__clang_max_align_nonce2)
         )
     );
 }
 pub type _Float32 = f32;
 pub type _Float64 = f64;
 pub type _Float32x = f64;
 pub type _Float64x = u128;
 pub type float_t = f32;
 pub type double_t = f64;
 extern "C" {
     pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn acos(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __acos(__x: f64) -> f64;
 }
 extern "C" {
     pub fn asin(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __asin(__x: f64) -> f64;
 }
 extern "C" {
     pub fn atan(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __atan(__x: f64) -> f64;
 }
 extern "C" {
     pub fn atan2(__y: f64, __x: f64) -> f64;
 }
 extern "C" {
     pub fn __atan2(__y: f64, __x: f64) -> f64;
 }
 extern "C" {
     pub fn cos(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __cos(__x: f64) -> f64;
 }
 extern "C" {
     pub fn sin(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __sin(__x: f64) -> f64;
 }
 extern "C" {
     pub fn tan(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __tan(__x: f64) -> f64;
 }
 extern "C" {
     pub fn cosh(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __cosh(__x: f64) -> f64;
 }
 extern "C" {
     pub fn sinh(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __sinh(__x: f64) -> f64;
 }
 extern "C" {
     pub fn tanh(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __tanh(__x: f64) -> f64;
 }
 extern "C" {
     pub fn acosh(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __acosh(__x: f64) -> f64;
 }
 extern "C" {
     pub fn asinh(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __asinh(__x: f64) -> f64;
 }
 extern "C" {
     pub fn atanh(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __atanh(__x: f64) -> f64;
 }
 extern "C" {
     pub fn exp(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __exp(__x: f64) -> f64;
 }
 extern "C" {
     pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
 }
 extern "C" {
     pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
 }
 extern "C" {
     pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
 }
 extern "C" {
     pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
 }
 extern "C" {
     pub fn log(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __log(__x: f64) -> f64;
 }
 extern "C" {
     pub fn log10(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __log10(__x: f64) -> f64;
 }
 extern "C" {
     pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
 }
 extern "C" {
     pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
 }
 extern "C" {
     pub fn expm1(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __expm1(__x: f64) -> f64;
 }
 extern "C" {
     pub fn log1p(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __log1p(__x: f64) -> f64;
 }
 extern "C" {
     pub fn logb(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __logb(__x: f64) -> f64;
 }
 extern "C" {
     pub fn exp2(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __exp2(__x: f64) -> f64;
 }
 extern "C" {
     pub fn log2(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __log2(__x: f64) -> f64;
 }
 extern "C" {
     pub fn pow(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn __pow(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn sqrt(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __sqrt(__x: f64) -> f64;
 }
 extern "C" {
     pub fn hypot(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn __hypot(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn cbrt(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __cbrt(__x: f64) -> f64;
 }
 extern "C" {
     pub fn ceil(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __ceil(__x: f64) -> f64;
 }
 extern "C" {
     pub fn fabs(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __fabs(__x: f64) -> f64;
 }
 extern "C" {
     pub fn floor(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __floor(__x: f64) -> f64;
 }
 extern "C" {
     pub fn fmod(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn __fmod(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn finite(__value: f64) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn drem(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn __drem(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn significand(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __significand(__x: f64) -> f64;
 }
 extern "C" {
     pub fn copysign(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn __copysign(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
 }
 extern "C" {
     pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
 }
 extern "C" {
     pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn j0(arg1: f64) -> f64;
 }
 extern "C" {
     pub fn __j0(arg1: f64) -> f64;
 }
 extern "C" {
     pub fn j1(arg1: f64) -> f64;
 }
 extern "C" {
     pub fn __j1(arg1: f64) -> f64;
 }
 extern "C" {
     pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
 }
 extern "C" {
     pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
 }
 extern "C" {
     pub fn y0(arg1: f64) -> f64;
 }
 extern "C" {
     pub fn __y0(arg1: f64) -> f64;
 }
 extern "C" {
     pub fn y1(arg1: f64) -> f64;
 }
 extern "C" {
     pub fn __y1(arg1: f64) -> f64;
 }
 extern "C" {
     pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
 }
 extern "C" {
     pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
 }
 extern "C" {
     pub fn erf(arg1: f64) -> f64;
 }
 extern "C" {
     pub fn __erf(arg1: f64) -> f64;
 }
 extern "C" {
     pub fn erfc(arg1: f64) -> f64;
 }
 extern "C" {
     pub fn __erfc(arg1: f64) -> f64;
 }
 extern "C" {
     pub fn lgamma(arg1: f64) -> f64;
 }
 extern "C" {
     pub fn __lgamma(arg1: f64) -> f64;
 }
 extern "C" {
     pub fn tgamma(arg1: f64) -> f64;
 }
 extern "C" {
     pub fn __tgamma(arg1: f64) -> f64;
 }
 extern "C" {
     pub fn gamma(arg1: f64) -> f64;
 }
 extern "C" {
     pub fn __gamma(arg1: f64) -> f64;
 }
 extern "C" {
     pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
 }
 extern "C" {
     pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
 }
 extern "C" {
     pub fn rint(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __rint(__x: f64) -> f64;
 }
 extern "C" {
     pub fn nextafter(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn __nextafter(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn nexttoward(__x: f64, __y: u128) -> f64;
 }
 extern "C" {
     pub fn __nexttoward(__x: f64, __y: u128) -> f64;
 }
 extern "C" {
     pub fn remainder(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn __remainder(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
 }
 extern "C" {
     pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
 }
 extern "C" {
     pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
 }
 extern "C" {
     pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
 }
 extern "C" {
     pub fn nearbyint(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __nearbyint(__x: f64) -> f64;
 }
 extern "C" {
     pub fn round(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __round(__x: f64) -> f64;
 }
 extern "C" {
     pub fn trunc(__x: f64) -> f64;
 }
 extern "C" {
     pub fn __trunc(__x: f64) -> f64;
 }
 extern "C" {
     pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
 }
 extern "C" {
     pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
 }
 extern "C" {
     pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
 }
 extern "C" {
     pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
 }
 extern "C" {
     pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
 }
 extern "C" {
     pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
 }
 extern "C" {
     pub fn lround(__x: f64) -> ::std::os::raw::c_long;
 }
 extern "C" {
     pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
 }
 extern "C" {
     pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
 }
 extern "C" {
     pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
 }
 extern "C" {
     pub fn fdim(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn __fdim(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn fmax(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn __fmax(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn fmin(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn __fmin(__x: f64, __y: f64) -> f64;
 }
 extern "C" {
     pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
 }
 extern "C" {
     pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
 }
 extern "C" {
     pub fn scalb(__x: f64, __n: f64) -> f64;
 }
 extern "C" {
     pub fn __scalb(__x: f64, __n: f64) -> f64;
 }
 extern "C" {
     pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn acosf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __acosf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn asinf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __asinf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn atanf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __atanf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn atan2f(__y: f32, __x: f32) -> f32;
 }
 extern "C" {
     pub fn __atan2f(__y: f32, __x: f32) -> f32;
 }
 extern "C" {
     pub fn cosf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __cosf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn sinf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __sinf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn tanf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __tanf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn coshf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __coshf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn sinhf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __sinhf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn tanhf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __tanhf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn acoshf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __acoshf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn asinhf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __asinhf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn atanhf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __atanhf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn expf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __expf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
 }
 extern "C" {
     pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
 }
 extern "C" {
     pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
 }
 extern "C" {
     pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
 }
 extern "C" {
     pub fn logf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __logf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn log10f(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __log10f(__x: f32) -> f32;
 }
 extern "C" {
     pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
 }
 extern "C" {
     pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
 }
 extern "C" {
     pub fn expm1f(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __expm1f(__x: f32) -> f32;
 }
 extern "C" {
     pub fn log1pf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __log1pf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn logbf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __logbf(__x: f32) -> f32;
 }
 extern "C" {
     pub fn exp2f(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __exp2f(__x: f32) -> f32;
 }
 extern "C" {
     pub fn log2f(__x: f32) -> f32;
 }
 extern "C" {
     pub fn __log2f(__x: f32) -> f32;
 }
 extern "C" {
     pub fn powf(__x: f32, __y: f32) -> f32;
 }
 extern "C" {
     pub fn __powf(__x: f32, __y: f32) -> f32;
 }
 // extern "C" {
 //     pub fn sqrtf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __sqrtf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn hypotf(__x: f32, __y: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __hypotf(__x: f32, __y: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn cbrtf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __cbrtf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn ceilf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __ceilf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn fabsf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __fabsf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn floorf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __floorf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn fmodf(__x: f32, __y: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __fmodf(__x: f32, __y: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
 // }
 // extern "C" {
 //     pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
 // }
 // extern "C" {
 //     pub fn dremf(__x: f32, __y: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __dremf(__x: f32, __y: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn significandf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __significandf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn copysignf(__x: f32, __y: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __copysignf(__x: f32, __y: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
 // }
 // extern "C" {
 //     pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
 // }
 // extern "C" {
 //     pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
 // }
 // extern "C" {
 //     pub fn j0f(arg1: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __j0f(arg1: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn j1f(arg1: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __j1f(arg1: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn y0f(arg1: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __y0f(arg1: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn y1f(arg1: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __y1f(arg1: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn erff(arg1: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __erff(arg1: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn erfcf(arg1: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __erfcf(arg1: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn lgammaf(arg1: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __lgammaf(arg1: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn tgammaf(arg1: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __tgammaf(arg1: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn gammaf(arg1: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __gammaf(arg1: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
 // }
 // extern "C" {
 //     pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
 // }
 // extern "C" {
 //     pub fn rintf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __rintf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn nextafterf(__x: f32, __y: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __nextafterf(__x: f32, __y: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn nexttowardf(__x: f32, __y: u128) -> f32;
 // }
 // extern "C" {
 //     pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
 // }
 // extern "C" {
 //     pub fn remainderf(__x: f32, __y: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __remainderf(__x: f32, __y: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
 // }
 // extern "C" {
 //     pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
 // }
 // extern "C" {
 //     pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
 // }
 // extern "C" {
 //     pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
 // }
 // extern "C" {
 //     pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
 // }
 // extern "C" {
 //     pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
 // }
 // extern "C" {
 //     pub fn nearbyintf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __nearbyintf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn roundf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __roundf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn truncf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __truncf(__x: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
 // }
 // extern "C" {
 //     pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
 // }
 // extern "C" {
 //     pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
 // }
 // extern "C" {
 //     pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
 // }
 // extern "C" {
 //     pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
 // }
 // extern "C" {
 //     pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
 // }
 // extern "C" {
 //     pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
 // }
 // extern "C" {
 //     pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
 // }
 // extern "C" {
 //     pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
 // }
 // extern "C" {
 //     pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
 // }
 // extern "C" {
 //     pub fn fdimf(__x: f32, __y: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __fdimf(__x: f32, __y: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn fmaxf(__x: f32, __y: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __fmaxf(__x: f32, __y: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn fminf(__x: f32, __y: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __fminf(__x: f32, __y: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn scalbf(__x: f32, __n: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __scalbf(__x: f32, __n: f32) -> f32;
 // }
 // extern "C" {
 //     pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
 // }
 // extern "C" {
 //     pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
 // }
 // extern "C" {
 //     pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
 // }
 // extern "C" {
 //     pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
 // }
 // extern "C" {
 //     pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
 // }
 // extern "C" {
 //     pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
 // }
 // extern "C" {
 //     pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
 // }
 // extern "C" {
 //     pub fn acosl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __acosl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn asinl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __asinl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn atanl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __atanl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn atan2l(__y: u128, __x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __atan2l(__y: u128, __x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn cosl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __cosl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn sinl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __sinl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn tanl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __tanl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn coshl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __coshl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn sinhl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __sinhl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn tanhl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __tanhl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn acoshl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __acoshl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn asinhl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __asinhl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn atanhl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __atanhl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn expl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __expl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
 // }
 // extern "C" {
 //     pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
 // }
 // extern "C" {
 //     pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
 // }
 // extern "C" {
 //     pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
 // }
 // extern "C" {
 //     pub fn logl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __logl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn log10l(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __log10l(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
 // }
 // extern "C" {
 //     pub fn expm1l(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __expm1l(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn log1pl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __log1pl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn logbl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __logbl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn exp2l(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __exp2l(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn log2l(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __log2l(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn powl(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __powl(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn sqrtl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __sqrtl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn hypotl(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __hypotl(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn cbrtl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __cbrtl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn ceill(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __ceill(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn fabsl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __fabsl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn floorl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __floorl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn fmodl(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __fmodl(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
 // }
 // extern "C" {
 //     pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
 // }
 // extern "C" {
 //     pub fn dreml(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __dreml(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn significandl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __significandl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn copysignl(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __copysignl(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
 // }
 // extern "C" {
 //     pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
 // }
 // extern "C" {
 //     pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
 // }
 // extern "C" {
 //     pub fn j0l(arg1: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __j0l(arg1: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn j1l(arg1: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __j1l(arg1: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn y0l(arg1: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __y0l(arg1: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn y1l(arg1: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __y1l(arg1: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn erfl(arg1: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __erfl(arg1: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn erfcl(arg1: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __erfcl(arg1: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn lgammal(arg1: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __lgammal(arg1: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn tgammal(arg1: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __tgammal(arg1: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn gammal(arg1: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __gammal(arg1: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
 // }
 // extern "C" {
 //     pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
 // }
 // extern "C" {
 //     pub fn rintl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __rintl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn nextafterl(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __nextafterl(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn nexttowardl(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn remainderl(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __remainderl(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
 // }
 // extern "C" {
 //     pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
 // }
 // extern "C" {
 //     pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
 // }
 // extern "C" {
 //     pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
 // }
 // extern "C" {
 //     pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
 // }
 // extern "C" {
 //     pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
 // }
 // extern "C" {
 //     pub fn nearbyintl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __nearbyintl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn roundl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __roundl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn truncl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __truncl(__x: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
 // }
 // extern "C" {
 //     pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
 // }
 // extern "C" {
 //     pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
 // }
 // extern "C" {
 //     pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
 // }
 // extern "C" {
 //     pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
 // }
 // extern "C" {
 //     pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
 // }
 // extern "C" {
 //     pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
 // }
 // extern "C" {
 //     pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
 // }
 // extern "C" {
 //     pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
 // }
 // extern "C" {
 //     pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
 // }
 // extern "C" {
 //     pub fn fdiml(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __fdiml(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn fmaxl(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __fmaxl(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn fminl(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __fminl(__x: u128, __y: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn scalbl(__x: u128, __n: u128) -> u128;
 // }
 // extern "C" {
 //     pub fn __scalbl(__x: u128, __n: u128) -> u128;
 // }
 extern "C" {
     pub static mut signgam: ::std::os::raw::c_int;
 }
 pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
 pub type __gwchar_t = ::std::os::raw::c_int;
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct imaxdiv_t {
     pub quot: ::std::os::raw::c_long,
     pub rem: ::std::os::raw::c_long,
 }
 #[test]
 fn bindgen_test_layout_imaxdiv_t() {
     const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<imaxdiv_t>(),
         16usize,
         concat!("Size of: ", stringify!(imaxdiv_t))
     );
     assert_eq!(
         ::std::mem::align_of::<imaxdiv_t>(),
         8usize,
         concat!("Alignment of ", stringify!(imaxdiv_t))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(imaxdiv_t),
             "::",
             stringify!(quot)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(imaxdiv_t),
             "::",
             stringify!(rem)
         )
     );
 }
 extern "C" {
     pub fn imaxabs(__n: intmax_t) -> intmax_t;
 }
 extern "C" {
     pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
 }
 extern "C" {
     pub fn strtoimax(
         __nptr: *const ::std::os::raw::c_char,
         __endptr: *mut *mut ::std::os::raw::c_char,
         __base: ::std::os::raw::c_int,
     ) -> intmax_t;
 }
 extern "C" {
     pub fn strtoumax(
         __nptr: *const ::std::os::raw::c_char,
         __endptr: *mut *mut ::std::os::raw::c_char,
         __base: ::std::os::raw::c_int,
     ) -> uintmax_t;
 }
 extern "C" {
     pub fn wcstoimax(
         __nptr: *const __gwchar_t,
         __endptr: *mut *mut __gwchar_t,
         __base: ::std::os::raw::c_int,
     ) -> intmax_t;
 }
 extern "C" {
     pub fn wcstoumax(
         __nptr: *const __gwchar_t,
         __endptr: *mut *mut __gwchar_t,
         __base: ::std::os::raw::c_int,
     ) -> uintmax_t;
 }
 pub type __gnuc_va_list = __builtin_va_list;
 pub type va_list = __builtin_va_list;
 #[doc = " \\class wl_object\n\n \\brief A protocol object.\n\n A `wl_object` is an opaque struct identifying the protocol object\n underlying a `wl_proxy` or `wl_resource`.\n\n \\note Functions accessing a `wl_object` are not normally used by client code.\n Clients should normally use the higher level interface generated by the\n scanner to interact with compositor objects.\n"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_object {
     _unused: [u8; 0],
 }
#[doc = " Protocol message signature\n\n A wl_message describes the signature of an actual protocol message, such as a\n request or event, that adheres to the Wayland protocol wire format. The\n protocol implementation uses a wl_message within its demarshal machinery for\n decoding messages between a compositor and its clients. In a sense, a\n wl_message is to a protocol message like a class is to an object.\n\n The `name` of a wl_message is the name of the corresponding protocol message.\n\n The `signature` is an ordered list of symbols representing the data types\n of message arguments and, optionally, a protocol version and indicators for\n nullability. A leading integer in the `signature` indicates the _since_\n version of the protocol message. A `?` preceding a data type symbol indicates\n that the following argument type is nullable. While it is a protocol violation\n to send messages with non-nullable arguments set to `NULL`, event handlers in\n clients might still get called with non-nullable object arguments set to\n `NULL`. This can happen when the client destroyed the object being used as\n argument on its side and an event referencing that object was sent before the\n server knew about its destruction. As this race cannot be prevented, clients\n should - as a general rule - program their event handlers such that they can\n handle object arguments declared non-nullable being `NULL` gracefully.\n\n When no arguments accompany a message, `signature` is an empty string.\n\n Symbols:\n\n * `i`: int\n * `u`: uint\n * `f`: fixed\n * `s`: string\n * `o`: object\n * `n`: new_id\n * `a`: array\n * `h`: fd\n * `?`: following argument (`o` or `s`) is nullable\n\n While demarshaling primitive arguments is straightforward, when demarshaling\n messages containing `object` or `new_id` arguments, the protocol\n implementation often must determine the type of the object. The `types` of a\n wl_message is an array of wl_interface references that correspond to `o` and\n `n` arguments in `signature`, with `NULL` placeholders for arguments with\n non-object types.\n\n Consider the protocol event wl_display `delete_id` that has a single `uint`\n argument. The wl_message is:\n\n \\code\n { \"delete_id\", \"u\", [NULL] }\n \\endcode\n\n Here, the message `name` is `\"delete_id\"`, the `signature` is `\"u\"`, and the\n argument `types` is `[NULL]`, indicating that the `uint` argument has no\n corresponding wl_interface since it is a primitive argument.\n\n In contrast, consider a `wl_foo` interface supporting protocol request `bar`\n that has existed since version 2, and has two arguments: a `uint` and an\n object of type `wl_baz_interface` that may be `NULL`. Such a `wl_message`\n might be:\n\n \\code\n { \"bar\", \"2u?o\", [NULL, &wl_baz_interface] }\n \\endcode\n\n Here, the message `name` is `\"bar\"`, and the `signature` is `\"2u?o\"`. Notice\n how the `2` indicates the protocol version, the `u` indicates the first\n argument type is `uint`, and the `?o` indicates that the second argument\n is an object that may be `NULL`. Lastly, the argument `types` array indicates\n that no wl_interface corresponds to the first argument, while the type\n `wl_baz_interface` corresponds to the second argument.\n\n \\sa wl_argument\n \\sa wl_interface\n \\sa <a href=\"https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-Wire-Format\">Wire Format</a>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_message {
    #[doc = " Message name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Message signature"]
    pub signature: *const ::std::os::raw::c_char,
    #[doc = " Object argument interfaces"]
    pub types: *mut *const wl_interface,
}
 #[test]
 fn bindgen_test_layout_wl_message() {
     const UNINIT: ::std::mem::MaybeUninit<wl_message> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_message>(),
         24usize,
         concat!("Size of: ", stringify!(wl_message))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_message>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_message))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_message),
             "::",
             stringify!(name)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_message),
             "::",
             stringify!(signature)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).types) as usize - ptr as usize },
         16usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_message),
             "::",
             stringify!(types)
         )
     );
 }
#[doc = " Protocol object interface\n\n A wl_interface describes the API of a protocol object defined in the Wayland\n protocol specification. The protocol implementation uses a wl_interface\n within its marshalling machinery for encoding client requests.\n\n The `name` of a wl_interface is the name of the corresponding protocol\n interface, and `version` represents the version of the interface. The members\n `method_count` and `event_count` represent the number of `methods` (requests)\n and `events` in the respective wl_message members.\n\n For example, consider a protocol interface `foo`, marked as version `1`, with\n two requests and one event.\n\n \\code{.xml}\n <interface name=\"foo\" version=\"1\">\n   <request name=\"a\"></request>\n   <request name=\"b\"></request>\n   <event name=\"c\"></event>\n </interface>\n \\endcode\n\n Given two wl_message arrays `foo_requests` and `foo_events`, a wl_interface\n for `foo` might be:\n\n \\code\n struct wl_interface foo_interface = {\n         \"foo\", 1,\n         2, foo_requests,\n         1, foo_events\n };\n \\endcode\n\n \\note The server side of the protocol may define interface <em>implementation\n       types</em> that incorporate the term `interface` in their name. Take\n       care to not confuse these server-side `struct`s with a wl_interface\n       variable whose name also ends in `interface`. For example, while the\n       server may define a type `struct wl_foo_interface`, the client may\n       define a `struct wl_interface wl_foo_interface`.\n\n \\sa wl_message\n \\sa wl_proxy\n \\sa <a href=\"https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-Interfaces\">Interfaces</a>\n \\sa <a href=\"https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-Versioning\">Versioning</a>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_interface {
    #[doc = " Interface name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Interface version"]
    pub version: ::std::os::raw::c_int,
    #[doc = " Number of methods (requests)"]
    pub method_count: ::std::os::raw::c_int,
    #[doc = " Method (request) signatures"]
    pub methods: *const wl_message,
    #[doc = " Number of events"]
    pub event_count: ::std::os::raw::c_int,
    #[doc = " Event signatures"]
    pub events: *const wl_message,
}
 #[test]
 fn bindgen_test_layout_wl_interface() {
     const UNINIT: ::std::mem::MaybeUninit<wl_interface> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_interface>(),
         40usize,
         concat!("Size of: ", stringify!(wl_interface))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_interface>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_interface))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_interface),
             "::",
             stringify!(name)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_interface),
             "::",
             stringify!(version)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).method_count) as usize - ptr as usize },
         12usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_interface),
             "::",
             stringify!(method_count)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).methods) as usize - ptr as usize },
         16usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_interface),
             "::",
             stringify!(methods)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).event_count) as usize - ptr as usize },
         24usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_interface),
             "::",
             stringify!(event_count)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
         32usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_interface),
             "::",
             stringify!(events)
         )
     );
 }
 #[doc = " \\class wl_list\n\n \\brief Doubly-linked list\n\n On its own, an instance of `struct wl_list` represents the sentinel head of\n a doubly-linked list, and must be initialized using wl_list_init().\n When empty, the list head's `next` and `prev` members point to the list head\n itself, otherwise `next` references the first element in the list, and `prev`\n refers to the last element in the list.\n\n Use the `struct wl_list` type to represent both the list head and the links\n between elements within the list. Use wl_list_empty() to determine if the\n list is empty in O(1).\n\n All elements in the list must be of the same type. The element type must have\n a `struct wl_list` member, often named `link` by convention. Prior to\n insertion, there is no need to initialize an element's `link` - invoking\n wl_list_init() on an individual list element's `struct wl_list` member is\n unnecessary if the very next operation is wl_list_insert(). However, a\n common idiom is to initialize an element's `link` prior to removal - ensure\n safety by invoking wl_list_init() before wl_list_remove().\n\n Consider a list reference `struct wl_list foo_list`, an element type as\n `struct element`, and an element's link member as `struct wl_list link`.\n\n The following code initializes a list and adds three elements to it.\n\n \\code\n struct wl_list foo_list;\n\n struct element {\n         int foo;\n         struct wl_list link;\n };\n struct element e1, e2, e3;\n\n wl_list_init(&foo_list);\n wl_list_insert(&foo_list, &e1.link);   // e1 is the first element\n wl_list_insert(&foo_list, &e2.link);   // e2 is now the first element\n wl_list_insert(&e2.link, &e3.link); // insert e3 after e2\n \\endcode\n\n The list now looks like <em>[e2, e3, e1]</em>.\n\n The `wl_list` API provides some iterator macros. For example, to iterate\n a list in ascending order:\n\n \\code\n struct element *e;\n wl_list_for_each(e, foo_list, link) {\n         do_something_with_element(e);\n }\n \\endcode\n\n See the documentation of each iterator for details.\n \\sa http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/linux/list.h"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_list {
     #[doc = " Previous list element"]
     pub prev: *mut wl_list,
     #[doc = " Next list element"]
     pub next: *mut wl_list,
 }
 #[test]
 fn bindgen_test_layout_wl_list() {
     const UNINIT: ::std::mem::MaybeUninit<wl_list> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_list>(),
         16usize,
         concat!("Size of: ", stringify!(wl_list))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_list>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_list))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_list),
             "::",
             stringify!(prev)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_list),
             "::",
             stringify!(next)
         )
     );
 }
 extern "C" {
     #[doc = " Initializes the list.\n\n \\param list List to initialize\n\n \\memberof wl_list"]
     pub fn wl_list_init(list: *mut wl_list);
 }
 extern "C" {
     #[doc = " Inserts an element into the list, after the element represented by \\p list.\n When \\p list is a reference to the list itself (the head), set the containing\n struct of \\p elm as the first element in the list.\n\n \\note If \\p elm is already part of a list, inserting it again will lead to\n       list corruption.\n\n \\param list List element after which the new element is inserted\n \\param elm Link of the containing struct to insert into the list\n\n \\memberof wl_list"]
     pub fn wl_list_insert(list: *mut wl_list, elm: *mut wl_list);
 }
 extern "C" {
     #[doc = " Removes an element from the list.\n\n \\note This operation leaves \\p elm in an invalid state.\n\n \\param elm Link of the containing struct to remove from the list\n\n \\memberof wl_list"]
     pub fn wl_list_remove(elm: *mut wl_list);
 }
 extern "C" {
     #[doc = " Determines the length of the list.\n\n \\note This is an O(n) operation.\n\n \\param list List whose length is to be determined\n\n \\return Number of elements in the list\n\n \\memberof wl_list"]
     pub fn wl_list_length(list: *const wl_list) -> ::std::os::raw::c_int;
 }
 extern "C" {
     #[doc = " Determines if the list is empty.\n\n \\param list List whose emptiness is to be determined\n\n \\return 1 if empty, or 0 if not empty\n\n \\memberof wl_list"]
     pub fn wl_list_empty(list: *const wl_list) -> ::std::os::raw::c_int;
 }
 extern "C" {
     #[doc = " Inserts all of the elements of one list into another, after the element\n represented by \\p list.\n\n \\note This leaves \\p other in an invalid state.\n\n \\param list List element after which the other list elements will be inserted\n \\param other List of elements to insert\n\n \\memberof wl_list"]
     pub fn wl_list_insert_list(list: *mut wl_list, other: *mut wl_list);
 }
#[doc = " \\class wl_array\n\n Dynamic array\n\n A wl_array is a dynamic array that can only grow until released. It is\n intended for relatively small allocations whose size is variable or not known\n in advance. While construction of a wl_array does not require all elements to\n be of the same size, wl_array_for_each() does require all elements to have\n the same type and size.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_array {
    #[doc = " Array size"]
    pub size: usize,
    #[doc = " Allocated space"]
    pub alloc: usize,
    #[doc = " Array data"]
    pub data: *mut ::std::os::raw::c_void,
}
 #[test]
 fn bindgen_test_layout_wl_array() {
     const UNINIT: ::std::mem::MaybeUninit<wl_array> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_array>(),
         24usize,
         concat!("Size of: ", stringify!(wl_array))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_array>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_array))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_array),
             "::",
             stringify!(size)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_array),
             "::",
             stringify!(alloc)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
         16usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_array),
             "::",
             stringify!(data)
         )
     );
 }
 extern "C" {
     #[doc = " Initializes the array.\n\n \\param array Array to initialize\n\n \\memberof wl_array"]
     pub fn wl_array_init(array: *mut wl_array);
 }
 extern "C" {
     #[doc = " Releases the array data.\n\n \\note Leaves the array in an invalid state.\n\n \\param array Array whose data is to be released\n\n \\memberof wl_array"]
     pub fn wl_array_release(array: *mut wl_array);
 }
 extern "C" {
     #[doc = " Increases the size of the array by \\p size bytes.\n\n \\param array Array whose size is to be increased\n \\param size Number of bytes to increase the size of the array by\n\n \\return A pointer to the beginning of the newly appended space, or NULL when\n         resizing fails.\n\n \\memberof wl_array"]
     pub fn wl_array_add(array: *mut wl_array, size: usize) -> *mut ::std::os::raw::c_void;
 }
 extern "C" {
     #[doc = " Copies the contents of \\p source to \\p array.\n\n \\param array Destination array to copy to\n \\param source Source array to copy from\n\n \\return 0 on success, or -1 on failure\n\n \\memberof wl_array"]
     pub fn wl_array_copy(array: *mut wl_array, source: *mut wl_array) -> ::std::os::raw::c_int;
 }
 #[doc = " Fixed-point number\n\n A `wl_fixed_t` is a 24.8 signed fixed-point number with a sign bit, 23 bits\n of integer precision and 8 bits of decimal precision. Consider `wl_fixed_t`\n as an opaque struct with methods that facilitate conversion to and from\n `double` and `int` types."]
 pub type wl_fixed_t = i32;
 #[doc = " Protocol message argument data types\n\n This union represents all of the argument types in the Wayland protocol wire\n format. The protocol implementation uses wl_argument within its marshalling\n machinery for dispatching messages between a client and a compositor.\n\n \\sa wl_message\n \\sa wl_interface\n \\sa <a href=\"https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-wire-Format\">Wire Format</a>"]
 #[repr(C)]
 #[derive(Copy, Clone)]
 pub union wl_argument {
     #[doc = "< `int`"]
     pub i: i32,
     #[doc = "< `uint`"]
     pub u: u32,
     #[doc = "< `fixed`"]
     pub f: wl_fixed_t,
     #[doc = "< `string`"]
     pub s: *const ::std::os::raw::c_char,
     #[doc = "< `object`"]
     pub o: *mut wl_object,
     #[doc = "< `new_id`"]
     pub n: u32,
     #[doc = "< `array`"]
     pub a: *mut wl_array,
     #[doc = "< `fd`"]
     pub h: i32,
 }
 #[test]
 fn bindgen_test_layout_wl_argument() {
     const UNINIT: ::std::mem::MaybeUninit<wl_argument> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_argument>(),
         8usize,
         concat!("Size of: ", stringify!(wl_argument))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_argument>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_argument))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_argument),
             "::",
             stringify!(i)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_argument),
             "::",
             stringify!(u)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_argument),
             "::",
             stringify!(f)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_argument),
             "::",
             stringify!(s)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).o) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_argument),
             "::",
             stringify!(o)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_argument),
             "::",
             stringify!(n)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_argument),
             "::",
             stringify!(a)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_argument),
             "::",
             stringify!(h)
         )
     );
 }
 #[doc = " Dispatcher function type alias\n\n A dispatcher is a function that handles the emitting of callbacks in client\n code. For programs directly using the C library, this is done by using\n libffi to call function pointers. When binding to languages other than C,\n dispatchers provide a way to abstract the function calling process to be\n friendlier to other function calling systems.\n\n A dispatcher takes five arguments: The first is the dispatcher-specific\n implementation associated with the target object. The second is the object\n upon which the callback is being invoked (either wl_proxy or wl_resource).\n The third and fourth arguments are the opcode and the wl_message\n corresponding to the callback. The final argument is an array of arguments\n received from the other process via the wire protocol.\n\n \\param user_data Dispatcher-specific implementation data\n \\param target Callback invocation target (wl_proxy or `wl_resource`)\n \\param opcode Callback opcode\n \\param msg Callback message signature\n \\param args Array of received arguments\n\n \\return 0 on success, or -1 on failure"]
 pub type wl_dispatcher_func_t = ::std::option::Option<
     unsafe extern "C" fn(
         user_data: *const ::std::os::raw::c_void,
         target: *mut ::std::os::raw::c_void,
         opcode: u32,
         msg: *const wl_message,
         args: *mut wl_argument,
     ) -> ::std::os::raw::c_int,
 >;
 #[doc = " Log function type alias\n\n The C implementation of the Wayland protocol abstracts the details of\n logging. Users may customize the logging behavior, with a function conforming\n to the `wl_log_func_t` type, via `wl_log_set_handler_client` and\n `wl_log_set_handler_server`.\n\n A `wl_log_func_t` must conform to the expectations of `vprintf`, and\n expects two arguments: a string to write and a corresponding variable\n argument list. While the string to write may contain format specifiers and\n use values in the variable argument list, the behavior of any `wl_log_func_t`\n depends on the implementation.\n\n \\note Take care to not confuse this with `wl_protocol_logger_func_t`, which\n       is a specific server-side logger for requests and events.\n\n \\param fmt String to write to the log, containing optional format\n            specifiers\n \\param args Variable argument list\n\n \\sa wl_log_set_handler_client\n \\sa wl_log_set_handler_server"]
 pub type wl_log_func_t = ::std::option::Option<
     unsafe extern "C" fn(fmt: *const ::std::os::raw::c_char, args: *mut __va_list_tag),
 >;
 #[doc = " Stop the iteration"]
 pub const wl_iterator_result_WL_ITERATOR_STOP: wl_iterator_result = 0;
 #[doc = " Continue the iteration"]
 pub const wl_iterator_result_WL_ITERATOR_CONTINUE: wl_iterator_result = 1;
 #[doc = " Return value of an iterator function\n\n \\sa wl_client_for_each_resource_iterator_func_t\n \\sa wl_client_for_each_resource"]
 pub type wl_iterator_result = ::std::os::raw::c_uint;
#[doc = " \\class wl_proxy\n\n \\brief Represents a protocol object on the client side.\n\n A wl_proxy acts as a client side proxy to an object existing in the\n compositor. The proxy is responsible for converting requests made by the\n clients with \\ref wl_proxy_marshal() into Wayland's wire format. Events\n coming from the compositor are also handled by the proxy, which will in\n turn call the handler set with \\ref wl_proxy_add_listener().\n\n \\note With the exception of function \\ref wl_proxy_set_queue(), functions\n accessing a wl_proxy are not normally used by client code. Clients\n should normally use the higher level interface generated by the scanner to\n interact with compositor objects.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_proxy {
    _unused: [u8; 0],
}
#[doc = " \\class wl_display\n\n \\brief Represents a connection to the compositor and acts as a proxy to\n the wl_display singleton object.\n\n A wl_display object represents a client connection to a Wayland\n compositor. It is created with either \\ref wl_display_connect() or\n \\ref wl_display_connect_to_fd(). A connection is terminated using\n \\ref wl_display_disconnect().\n\n A wl_display is also used as the \\ref wl_proxy for the wl_display\n singleton object on the compositor side.\n\n A wl_display object handles all the data sent from and to the\n compositor. When a \\ref wl_proxy marshals a request, it will write its wire\n representation to the display's write buffer. The data is sent to the\n compositor when the client calls \\ref wl_display_flush().\n\n Incoming data is handled in two steps: queueing and dispatching. In the\n queue step, the data coming from the display fd is interpreted and\n added to a queue. On the dispatch step, the handler for the incoming\n event set by the client on the corresponding \\ref wl_proxy is called.\n\n A wl_display has at least one event queue, called the <em>default\n queue</em>. Clients can create additional event queues with \\ref\n wl_display_create_queue() and assign \\ref wl_proxy's to it. Events\n occurring in a particular proxy are always queued in its assigned queue.\n A client can ensure that a certain assumption, such as holding a lock\n or running from a given thread, is true when a proxy event handler is\n called by assigning that proxy to an event queue and making sure that\n this queue is only dispatched when the assumption holds.\n\n The default queue is dispatched by calling \\ref wl_display_dispatch().\n This will dispatch any events queued on the default queue and attempt\n to read from the display fd if it's empty. Events read are then queued\n on the appropriate queues according to the proxy assignment.\n\n A user created queue is dispatched with \\ref wl_display_dispatch_queue().\n This function behaves exactly the same as wl_display_dispatch()\n but it dispatches given queue instead of the default queue.\n\n A real world example of event queue usage is Mesa's implementation of\n eglSwapBuffers() for the Wayland platform. This function might need\n to block until a frame callback is received, but dispatching the default\n queue could cause an event handler on the client to start drawing\n again. This problem is solved using another event queue, so that only\n the events handled by the EGL code are dispatched during the block.\n\n This creates a problem where a thread dispatches a non-default\n queue, reading all the data from the display fd. If the application\n would call \\em poll(2) after that it would block, even though there\n might be events queued on the default queue. Those events should be\n dispatched with \\ref wl_display_dispatch_pending() or \\ref\n wl_display_dispatch_queue_pending() before flushing and blocking."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_display {
    _unused: [u8; 0],
}
 #[doc = " \\class wl_event_queue\n\n \\brief A queue for \\ref wl_proxy object events.\n\n Event queues allows the events on a display to be handled in a thread-safe\n manner. See \\ref wl_display for details.\n"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_event_queue {
     _unused: [u8; 0],
 }
 extern "C" {
     pub fn wl_event_queue_destroy(queue: *mut wl_event_queue);
 }
extern "C" {
    pub fn wl_proxy_marshal_flags(
        proxy: *mut wl_proxy,
        opcode: u32,
        interface: *const wl_interface,
        version: u32,
        flags: u32,
        ...
    ) -> *mut wl_proxy;
}
 extern "C" {
     pub fn wl_proxy_marshal_array_flags(
         proxy: *mut wl_proxy,
         opcode: u32,
         interface: *const wl_interface,
         version: u32,
         flags: u32,
         args: *mut wl_argument,
     ) -> *mut wl_proxy;
 }
 extern "C" {
     pub fn wl_proxy_marshal(p: *mut wl_proxy, opcode: u32, ...);
 }
 extern "C" {
     pub fn wl_proxy_marshal_array(p: *mut wl_proxy, opcode: u32, args: *mut wl_argument);
 }
 extern "C" {
     pub fn wl_proxy_create(factory: *mut wl_proxy, interface: *const wl_interface)
         -> *mut wl_proxy;
 }
 extern "C" {
     pub fn wl_proxy_create_wrapper(
         proxy: *mut ::std::os::raw::c_void,
     ) -> *mut ::std::os::raw::c_void;
 }
 extern "C" {
     pub fn wl_proxy_wrapper_destroy(proxy_wrapper: *mut ::std::os::raw::c_void);
 }
 extern "C" {
     pub fn wl_proxy_marshal_constructor(
         proxy: *mut wl_proxy,
         opcode: u32,
         interface: *const wl_interface,
         ...
     ) -> *mut wl_proxy;
 }
 extern "C" {
     pub fn wl_proxy_marshal_constructor_versioned(
         proxy: *mut wl_proxy,
         opcode: u32,
         interface: *const wl_interface,
         version: u32,
         ...
     ) -> *mut wl_proxy;
 }
 extern "C" {
     pub fn wl_proxy_marshal_array_constructor(
         proxy: *mut wl_proxy,
         opcode: u32,
         args: *mut wl_argument,
         interface: *const wl_interface,
     ) -> *mut wl_proxy;
 }
 extern "C" {
     pub fn wl_proxy_marshal_array_constructor_versioned(
         proxy: *mut wl_proxy,
         opcode: u32,
         args: *mut wl_argument,
         interface: *const wl_interface,
         version: u32,
     ) -> *mut wl_proxy;
 }
 extern "C" {
     pub fn wl_proxy_destroy(proxy: *mut wl_proxy);
 }
extern "C" {
    pub fn wl_proxy_add_listener(
        proxy: *mut wl_proxy,
        implementation: *mut ::std::option::Option<unsafe extern "C" fn()>,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
 extern "C" {
     pub fn wl_proxy_get_listener(proxy: *mut wl_proxy) -> *const ::std::os::raw::c_void;
 }
 extern "C" {
     pub fn wl_proxy_add_dispatcher(
         proxy: *mut wl_proxy,
         dispatcher_func: wl_dispatcher_func_t,
         dispatcher_data: *const ::std::os::raw::c_void,
         data: *mut ::std::os::raw::c_void,
     ) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn wl_proxy_set_user_data(proxy: *mut wl_proxy, user_data: *mut ::std::os::raw::c_void);
 }
 extern "C" {
     pub fn wl_proxy_get_user_data(proxy: *mut wl_proxy) -> *mut ::std::os::raw::c_void;
 }
extern "C" {
    pub fn wl_proxy_get_version(proxy: *mut wl_proxy) -> u32;
}
 extern "C" {
     pub fn wl_proxy_get_id(proxy: *mut wl_proxy) -> u32;
 }
 extern "C" {
     pub fn wl_proxy_set_tag(proxy: *mut wl_proxy, tag: *const *const ::std::os::raw::c_char);
 }
 extern "C" {
     pub fn wl_proxy_get_tag(proxy: *mut wl_proxy) -> *const *const ::std::os::raw::c_char;
 }
 extern "C" {
     pub fn wl_proxy_get_class(proxy: *mut wl_proxy) -> *const ::std::os::raw::c_char;
 }
 extern "C" {
     pub fn wl_proxy_set_queue(proxy: *mut wl_proxy, queue: *mut wl_event_queue);
 }
extern "C" {
    pub fn wl_display_connect(name: *const ::std::os::raw::c_char) -> *mut wl_display;
}
 extern "C" {
     pub fn wl_display_connect_to_fd(fd: ::std::os::raw::c_int) -> *mut wl_display;
 }
 extern "C" {
     pub fn wl_display_disconnect(display: *mut wl_display);
 }
 extern "C" {
     pub fn wl_display_get_fd(display: *mut wl_display) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn wl_display_dispatch(display: *mut wl_display) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn wl_display_dispatch_queue(
         display: *mut wl_display,
         queue: *mut wl_event_queue,
     ) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn wl_display_dispatch_queue_pending(
         display: *mut wl_display,
         queue: *mut wl_event_queue,
     ) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn wl_display_dispatch_pending(display: *mut wl_display) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn wl_display_get_error(display: *mut wl_display) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn wl_display_get_protocol_error(
         display: *mut wl_display,
         interface: *mut *const wl_interface,
         id: *mut u32,
     ) -> u32;
 }
 extern "C" {
     pub fn wl_display_flush(display: *mut wl_display) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn wl_display_roundtrip_queue(
         display: *mut wl_display,
         queue: *mut wl_event_queue,
     ) -> ::std::os::raw::c_int;
 }
extern "C" {
    pub fn wl_display_roundtrip(display: *mut wl_display) -> ::std::os::raw::c_int;
}
 extern "C" {
     pub fn wl_display_create_queue(display: *mut wl_display) -> *mut wl_event_queue;
 }
 extern "C" {
     pub fn wl_display_prepare_read_queue(
         display: *mut wl_display,
         queue: *mut wl_event_queue,
     ) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn wl_display_prepare_read(display: *mut wl_display) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn wl_display_cancel_read(display: *mut wl_display);
 }
 extern "C" {
     pub fn wl_display_read_events(display: *mut wl_display) -> ::std::os::raw::c_int;
 }
 extern "C" {
     pub fn wl_log_set_handler_client(handler: wl_log_func_t);
 }
 #[doc = " @page page_wayland The wayland protocol\n @section page_ifaces_wayland Interfaces\n - @subpage page_iface_wl_display - core global object\n - @subpage page_iface_wl_registry - global registry object\n - @subpage page_iface_wl_callback - callback object\n - @subpage page_iface_wl_compositor - the compositor singleton\n - @subpage page_iface_wl_shm_pool - a shared memory pool\n - @subpage page_iface_wl_shm - shared memory support\n - @subpage page_iface_wl_buffer - content for a wl_surface\n - @subpage page_iface_wl_data_offer - offer to transfer data\n - @subpage page_iface_wl_data_source - offer to transfer data\n - @subpage page_iface_wl_data_device - data transfer device\n - @subpage page_iface_wl_data_device_manager - data transfer interface\n - @subpage page_iface_wl_shell - create desktop-style surfaces\n - @subpage page_iface_wl_shell_surface - desktop-style metadata interface\n - @subpage page_iface_wl_surface - an onscreen surface\n - @subpage page_iface_wl_seat - group of input devices\n - @subpage page_iface_wl_pointer - pointer input device\n - @subpage page_iface_wl_keyboard - keyboard input device\n - @subpage page_iface_wl_touch - touchscreen input device\n - @subpage page_iface_wl_output - compositor output region\n - @subpage page_iface_wl_region - region interface\n - @subpage page_iface_wl_subcompositor - sub-surface compositing\n - @subpage page_iface_wl_subsurface - sub-surface interface to a wl_surface\n @section page_copyright_wayland Copyright\n <pre>\n\n Copyright  2008-2011 Kristian Hgsberg\n Copyright  2010-2011 Intel Corporation\n Copyright  2012-2013 Collabora, Ltd.\n\n Permission is hereby granted, free of charge, to any person\n obtaining a copy of this software and associated documentation files\n (the \"Software\"), to deal in the Software without restriction,\n including without limitation the rights to use, copy, modify, merge,\n publish, distribute, sublicense, and/or sell copies of the Software,\n and to permit persons to whom the Software is furnished to do so,\n subject to the following conditions:\n\n The above copyright notice and this permission notice (including the\n next paragraph) shall be included in all copies or substantial\n portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n </pre>"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_buffer {
     _unused: [u8; 0],
 }
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_callback {
     _unused: [u8; 0],
 }
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_compositor {
    _unused: [u8; 0],
}
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_data_device {
     _unused: [u8; 0],
 }
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_data_device_manager {
     _unused: [u8; 0],
 }
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_data_offer {
     _unused: [u8; 0],
 }
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_data_source {
     _unused: [u8; 0],
 }
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_keyboard {
     _unused: [u8; 0],
 }
 #[doc = " @page page_xdg_shell The xdg_shell protocol\n @section page_ifaces_xdg_shell Interfaces\n - @subpage page_iface_xdg_wm_base - create desktop-style surfaces\n - @subpage page_iface_xdg_positioner - child surface positioner\n - @subpage page_iface_xdg_surface - desktop user interface surface base interface\n - @subpage page_iface_xdg_toplevel - toplevel surface\n - @subpage page_iface_xdg_popup - short-lived, popup surfaces for menus\n @section page_copyright_xdg_shell Copyright\n <pre>\n\n Copyright  2008-2013 Kristian Hgsberg\n Copyright  2013      Rafael Antognolli\n Copyright  2013      Jasper St. Pierre\n Copyright  2010-2013 Intel Corporation\n Copyright  2015-2017 Samsung Electronics Co., Ltd\n Copyright  2015-2017 Red Hat Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a\n copy of this software and associated documentation files (the \"Software\"),\n to deal in the Software without restriction, including without limitation\n the rights to use, copy, modify, merge, publish, distribute, sublicense,\n and/or sell copies of the Software, and to permit persons to whom the\n Software is furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice (including the next\n paragraph) shall be included in all copies or substantial portions of the\n Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n DEALINGS IN THE SOFTWARE.\n </pre>"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_output {
     _unused: [u8; 0],
 }
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_pointer {
     _unused: [u8; 0],
 }
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_region {
     _unused: [u8; 0],
 }
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_registry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_seat {
    _unused: [u8; 0],
}
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_shell {
     _unused: [u8; 0],
 }
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_shell_surface {
     _unused: [u8; 0],
 }
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_shm {
     _unused: [u8; 0],
 }
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_shm_pool {
     _unused: [u8; 0],
 }
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_subcompositor {
     _unused: [u8; 0],
 }
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_subsurface {
     _unused: [u8; 0],
 }
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_surface {
    _unused: [u8; 0],
}
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_touch {
     _unused: [u8; 0],
 }
 extern "C" {
     #[doc = " @page page_iface_wl_display wl_display\n @section page_iface_wl_display_desc Description\n\n The core global object.  This is a special singleton object.  It\n is used for internal Wayland protocol features.\n @section page_iface_wl_display_api API\n See @ref iface_wl_display.\n/\n/**\n @defgroup iface_wl_display The wl_display interface\n\n The core global object.  This is a special singleton object.  It\n is used for internal Wayland protocol features."]
     pub static wl_display_interface: wl_interface;
 }
extern "C" {
    #[doc = " @page page_iface_wl_registry wl_registry\n @section page_iface_wl_registry_desc Description\n\n The singleton global registry object.  The server has a number of\n global objects that are available to all clients.  These objects\n typically represent an actual object in the server (for example,\n an input device) or they are singleton objects that provide\n extension functionality.\n\n When a client creates a registry object, the registry object\n will emit a global event for each global currently in the\n registry.  Globals come and go as a result of device or\n monitor hotplugs, reconfiguration or other events, and the\n registry will send out global and global_remove events to\n keep the client up to date with the changes.  To mark the end\n of the initial burst of events, the client can use the\n wl_display.sync request immediately after calling\n wl_display.get_registry.\n\n A client can bind to a global object by using the bind\n request.  This creates a client-side handle that lets the object\n emit events to the client and lets the client invoke requests on\n the object.\n @section page_iface_wl_registry_api API\n See @ref iface_wl_registry.\n/\n/**\n @defgroup iface_wl_registry The wl_registry interface\n\n The singleton global registry object.  The server has a number of\n global objects that are available to all clients.  These objects\n typically represent an actual object in the server (for example,\n an input device) or they are singleton objects that provide\n extension functionality.\n\n When a client creates a registry object, the registry object\n will emit a global event for each global currently in the\n registry.  Globals come and go as a result of device or\n monitor hotplugs, reconfiguration or other events, and the\n registry will send out global and global_remove events to\n keep the client up to date with the changes.  To mark the end\n of the initial burst of events, the client can use the\n wl_display.sync request immediately after calling\n wl_display.get_registry.\n\n A client can bind to a global object by using the bind\n request.  This creates a client-side handle that lets the object\n emit events to the client and lets the client invoke requests on\n the object."]
    pub static wl_registry_interface: wl_interface;
}
 extern "C" {
     #[doc = " @page page_iface_wl_callback wl_callback\n @section page_iface_wl_callback_desc Description\n\n Clients can handle the 'done' event to get notified when\n the related request is done.\n\n Note, because wl_callback objects are created from multiple independent\n factory interfaces, the wl_callback interface is frozen at version 1.\n @section page_iface_wl_callback_api API\n See @ref iface_wl_callback.\n/\n/**\n @defgroup iface_wl_callback The wl_callback interface\n\n Clients can handle the 'done' event to get notified when\n the related request is done.\n\n Note, because wl_callback objects are created from multiple independent\n factory interfaces, the wl_callback interface is frozen at version 1."]
     pub static wl_callback_interface: wl_interface;
 }
extern "C" {
    #[doc = " @page page_iface_wl_compositor wl_compositor\n @section page_iface_wl_compositor_desc Description\n\n A compositor.  This object is a singleton global.  The\n compositor is in charge of combining the contents of multiple\n surfaces into one displayable output.\n @section page_iface_wl_compositor_api API\n See @ref iface_wl_compositor.\n/\n/**\n @defgroup iface_wl_compositor The wl_compositor interface\n\n A compositor.  This object is a singleton global.  The\n compositor is in charge of combining the contents of multiple\n surfaces into one displayable output."]
    pub static wl_compositor_interface: wl_interface;
}
 extern "C" {
     #[doc = " @page page_iface_wl_shm_pool wl_shm_pool\n @section page_iface_wl_shm_pool_desc Description\n\n The wl_shm_pool object encapsulates a piece of memory shared\n between the compositor and client.  Through the wl_shm_pool\n object, the client can allocate shared memory wl_buffer objects.\n All objects created through the same pool share the same\n underlying mapped memory. Reusing the mapped memory avoids the\n setup/teardown overhead and is useful when interactively resizing\n a surface or for many small buffers.\n @section page_iface_wl_shm_pool_api API\n See @ref iface_wl_shm_pool.\n/\n/**\n @defgroup iface_wl_shm_pool The wl_shm_pool interface\n\n The wl_shm_pool object encapsulates a piece of memory shared\n between the compositor and client.  Through the wl_shm_pool\n object, the client can allocate shared memory wl_buffer objects.\n All objects created through the same pool share the same\n underlying mapped memory. Reusing the mapped memory avoids the\n setup/teardown overhead and is useful when interactively resizing\n a surface or for many small buffers."]
     pub static wl_shm_pool_interface: wl_interface;
 }
 extern "C" {
     #[doc = " @page page_iface_wl_shm wl_shm\n @section page_iface_wl_shm_desc Description\n\n A singleton global object that provides support for shared\n memory.\n\n Clients can create wl_shm_pool objects using the create_pool\n request.\n\n On binding the wl_shm object one or more format events\n are emitted to inform clients about the valid pixel formats\n that can be used for buffers.\n @section page_iface_wl_shm_api API\n See @ref iface_wl_shm.\n/\n/**\n @defgroup iface_wl_shm The wl_shm interface\n\n A singleton global object that provides support for shared\n memory.\n\n Clients can create wl_shm_pool objects using the create_pool\n request.\n\n On binding the wl_shm object one or more format events\n are emitted to inform clients about the valid pixel formats\n that can be used for buffers."]
     pub static wl_shm_interface: wl_interface;
 }
 extern "C" {
     #[doc = " @page page_iface_wl_buffer wl_buffer\n @section page_iface_wl_buffer_desc Description\n\n A buffer provides the content for a wl_surface. Buffers are\n created through factory interfaces such as wl_shm, wp_linux_buffer_params\n (from the linux-dmabuf protocol extension) or similar. It has a width and\n a height and can be attached to a wl_surface, but the mechanism by which a\n client provides and updates the contents is defined by the buffer factory\n interface.\n\n If the buffer uses a format that has an alpha channel, the alpha channel\n is assumed to be premultiplied in the color channels unless otherwise\n specified.\n\n Note, because wl_buffer objects are created from multiple independent\n factory interfaces, the wl_buffer interface is frozen at version 1.\n @section page_iface_wl_buffer_api API\n See @ref iface_wl_buffer.\n/\n/**\n @defgroup iface_wl_buffer The wl_buffer interface\n\n A buffer provides the content for a wl_surface. Buffers are\n created through factory interfaces such as wl_shm, wp_linux_buffer_params\n (from the linux-dmabuf protocol extension) or similar. It has a width and\n a height and can be attached to a wl_surface, but the mechanism by which a\n client provides and updates the contents is defined by the buffer factory\n interface.\n\n If the buffer uses a format that has an alpha channel, the alpha channel\n is assumed to be premultiplied in the color channels unless otherwise\n specified.\n\n Note, because wl_buffer objects are created from multiple independent\n factory interfaces, the wl_buffer interface is frozen at version 1."]
     pub static wl_buffer_interface: wl_interface;
 }
 extern "C" {
     #[doc = " @page page_iface_wl_data_offer wl_data_offer\n @section page_iface_wl_data_offer_desc Description\n\n A wl_data_offer represents a piece of data offered for transfer\n by another client (the source client).  It is used by the\n copy-and-paste and drag-and-drop mechanisms.  The offer\n describes the different mime types that the data can be\n converted to and provides the mechanism for transferring the\n data directly from the source client.\n @section page_iface_wl_data_offer_api API\n See @ref iface_wl_data_offer.\n/\n/**\n @defgroup iface_wl_data_offer The wl_data_offer interface\n\n A wl_data_offer represents a piece of data offered for transfer\n by another client (the source client).  It is used by the\n copy-and-paste and drag-and-drop mechanisms.  The offer\n describes the different mime types that the data can be\n converted to and provides the mechanism for transferring the\n data directly from the source client."]
     pub static wl_data_offer_interface: wl_interface;
 }
 extern "C" {
     #[doc = " @page page_iface_wl_data_source wl_data_source\n @section page_iface_wl_data_source_desc Description\n\n The wl_data_source object is the source side of a wl_data_offer.\n It is created by the source client in a data transfer and\n provides a way to describe the offered data and a way to respond\n to requests to transfer the data.\n @section page_iface_wl_data_source_api API\n See @ref iface_wl_data_source.\n/\n/**\n @defgroup iface_wl_data_source The wl_data_source interface\n\n The wl_data_source object is the source side of a wl_data_offer.\n It is created by the source client in a data transfer and\n provides a way to describe the offered data and a way to respond\n to requests to transfer the data."]
     pub static wl_data_source_interface: wl_interface;
 }
 extern "C" {
     #[doc = " @page page_iface_wl_data_device wl_data_device\n @section page_iface_wl_data_device_desc Description\n\n There is one wl_data_device per seat which can be obtained\n from the global wl_data_device_manager singleton.\n\n A wl_data_device provides access to inter-client data transfer\n mechanisms such as copy-and-paste and drag-and-drop.\n @section page_iface_wl_data_device_api API\n See @ref iface_wl_data_device.\n/\n/**\n @defgroup iface_wl_data_device The wl_data_device interface\n\n There is one wl_data_device per seat which can be obtained\n from the global wl_data_device_manager singleton.\n\n A wl_data_device provides access to inter-client data transfer\n mechanisms such as copy-and-paste and drag-and-drop."]
     pub static wl_data_device_interface: wl_interface;
 }
 extern "C" {
     #[doc = " @page page_iface_wl_data_device_manager wl_data_device_manager\n @section page_iface_wl_data_device_manager_desc Description\n\n The wl_data_device_manager is a singleton global object that\n provides access to inter-client data transfer mechanisms such as\n copy-and-paste and drag-and-drop.  These mechanisms are tied to\n a wl_seat and this interface lets a client get a wl_data_device\n corresponding to a wl_seat.\n\n Depending on the version bound, the objects created from the bound\n wl_data_device_manager object will have different requirements for\n functioning properly. See wl_data_source.set_actions,\n wl_data_offer.accept and wl_data_offer.finish for details.\n @section page_iface_wl_data_device_manager_api API\n See @ref iface_wl_data_device_manager.\n/\n/**\n @defgroup iface_wl_data_device_manager The wl_data_device_manager interface\n\n The wl_data_device_manager is a singleton global object that\n provides access to inter-client data transfer mechanisms such as\n copy-and-paste and drag-and-drop.  These mechanisms are tied to\n a wl_seat and this interface lets a client get a wl_data_device\n corresponding to a wl_seat.\n\n Depending on the version bound, the objects created from the bound\n wl_data_device_manager object will have different requirements for\n functioning properly. See wl_data_source.set_actions,\n wl_data_offer.accept and wl_data_offer.finish for details."]
     pub static wl_data_device_manager_interface: wl_interface;
 }
 extern "C" {
     #[doc = " @page page_iface_wl_shell wl_shell\n @section page_iface_wl_shell_desc Description\n\n This interface is implemented by servers that provide\n desktop-style user interfaces.\n\n It allows clients to associate a wl_shell_surface with\n a basic surface.\n\n Note! This protocol is deprecated and not intended for production use.\n For desktop-style user interfaces, use xdg_shell. Compositors and clients\n should not implement this interface.\n @section page_iface_wl_shell_api API\n See @ref iface_wl_shell.\n/\n/**\n @defgroup iface_wl_shell The wl_shell interface\n\n This interface is implemented by servers that provide\n desktop-style user interfaces.\n\n It allows clients to associate a wl_shell_surface with\n a basic surface.\n\n Note! This protocol is deprecated and not intended for production use.\n For desktop-style user interfaces, use xdg_shell. Compositors and clients\n should not implement this interface."]
     pub static wl_shell_interface: wl_interface;
 }
 extern "C" {
     #[doc = " @page page_iface_wl_shell_surface wl_shell_surface\n @section page_iface_wl_shell_surface_desc Description\n\n An interface that may be implemented by a wl_surface, for\n implementations that provide a desktop-style user interface.\n\n It provides requests to treat surfaces like toplevel, fullscreen\n or popup windows, move, resize or maximize them, associate\n metadata like title and class, etc.\n\n On the server side the object is automatically destroyed when\n the related wl_surface is destroyed. On the client side,\n wl_shell_surface_destroy() must be called before destroying\n the wl_surface object.\n @section page_iface_wl_shell_surface_api API\n See @ref iface_wl_shell_surface.\n/\n/**\n @defgroup iface_wl_shell_surface The wl_shell_surface interface\n\n An interface that may be implemented by a wl_surface, for\n implementations that provide a desktop-style user interface.\n\n It provides requests to treat surfaces like toplevel, fullscreen\n or popup windows, move, resize or maximize them, associate\n metadata like title and class, etc.\n\n On the server side the object is automatically destroyed when\n the related wl_surface is destroyed. On the client side,\n wl_shell_surface_destroy() must be called before destroying\n the wl_surface object."]
     pub static wl_shell_surface_interface: wl_interface;
 }
extern "C" {
    #[doc = " @page page_iface_wl_surface wl_surface\n @section page_iface_wl_surface_desc Description\n\n A surface is a rectangular area that may be displayed on zero\n or more outputs, and shown any number of times at the compositor's\n discretion. They can present wl_buffers, receive user input, and\n define a local coordinate system.\n\n The size of a surface (and relative positions on it) is described\n in surface-local coordinates, which may differ from the buffer\n coordinates of the pixel content, in case a buffer_transform\n or a buffer_scale is used.\n\n A surface without a \"role\" is fairly useless: a compositor does\n not know where, when or how to present it. The role is the\n purpose of a wl_surface. Examples of roles are a cursor for a\n pointer (as set by wl_pointer.set_cursor), a drag icon\n (wl_data_device.start_drag), a sub-surface\n (wl_subcompositor.get_subsurface), and a window as defined by a\n shell protocol (e.g. wl_shell.get_shell_surface).\n\n A surface can have only one role at a time. Initially a\n wl_surface does not have a role. Once a wl_surface is given a\n role, it is set permanently for the whole lifetime of the\n wl_surface object. Giving the current role again is allowed,\n unless explicitly forbidden by the relevant interface\n specification.\n\n Surface roles are given by requests in other interfaces such as\n wl_pointer.set_cursor. The request should explicitly mention\n that this request gives a role to a wl_surface. Often, this\n request also creates a new protocol object that represents the\n role and adds additional functionality to wl_surface. When a\n client wants to destroy a wl_surface, they must destroy this role\n object before the wl_surface, otherwise a defunct_role_object error is\n sent.\n\n Destroying the role object does not remove the role from the\n wl_surface, but it may stop the wl_surface from \"playing the role\".\n For instance, if a wl_subsurface object is destroyed, the wl_surface\n it was created for will be unmapped and forget its position and\n z-order. It is allowed to create a wl_subsurface for the same\n wl_surface again, but it is not allowed to use the wl_surface as\n a cursor (cursor is a different role than sub-surface, and role\n switching is not allowed).\n @section page_iface_wl_surface_api API\n See @ref iface_wl_surface.\n/\n/**\n @defgroup iface_wl_surface The wl_surface interface\n\n A surface is a rectangular area that may be displayed on zero\n or more outputs, and shown any number of times at the compositor's\n discretion. They can present wl_buffers, receive user input, and\n define a local coordinate system.\n\n The size of a surface (and relative positions on it) is described\n in surface-local coordinates, which may differ from the buffer\n coordinates of the pixel content, in case a buffer_transform\n or a buffer_scale is used.\n\n A surface without a \"role\" is fairly useless: a compositor does\n not know where, when or how to present it. The role is the\n purpose of a wl_surface. Examples of roles are a cursor for a\n pointer (as set by wl_pointer.set_cursor), a drag icon\n (wl_data_device.start_drag), a sub-surface\n (wl_subcompositor.get_subsurface), and a window as defined by a\n shell protocol (e.g. wl_shell.get_shell_surface).\n\n A surface can have only one role at a time. Initially a\n wl_surface does not have a role. Once a wl_surface is given a\n role, it is set permanently for the whole lifetime of the\n wl_surface object. Giving the current role again is allowed,\n unless explicitly forbidden by the relevant interface\n specification.\n\n Surface roles are given by requests in other interfaces such as\n wl_pointer.set_cursor. The request should explicitly mention\n that this request gives a role to a wl_surface. Often, this\n request also creates a new protocol object that represents the\n role and adds additional functionality to wl_surface. When a\n client wants to destroy a wl_surface, they must destroy this role\n object before the wl_surface, otherwise a defunct_role_object error is\n sent.\n\n Destroying the role object does not remove the role from the\n wl_surface, but it may stop the wl_surface from \"playing the role\".\n For instance, if a wl_subsurface object is destroyed, the wl_surface\n it was created for will be unmapped and forget its position and\n z-order. It is allowed to create a wl_subsurface for the same\n wl_surface again, but it is not allowed to use the wl_surface as\n a cursor (cursor is a different role than sub-surface, and role\n switching is not allowed)."]
    pub static wl_surface_interface: wl_interface;
}
extern "C" {
    #[doc = " @page page_iface_wl_seat wl_seat\n @section page_iface_wl_seat_desc Description\n\n A seat is a group of keyboards, pointer and touch devices. This\n object is published as a global during start up, or when such a\n device is hot plugged.  A seat typically has a pointer and\n maintains a keyboard focus and a pointer focus.\n @section page_iface_wl_seat_api API\n See @ref iface_wl_seat.\n/\n/**\n @defgroup iface_wl_seat The wl_seat interface\n\n A seat is a group of keyboards, pointer and touch devices. This\n object is published as a global during start up, or when such a\n device is hot plugged.  A seat typically has a pointer and\n maintains a keyboard focus and a pointer focus."]
    pub static wl_seat_interface: wl_interface;
}
 extern "C" {
     #[doc = " @page page_iface_wl_pointer wl_pointer\n @section page_iface_wl_pointer_desc Description\n\n The wl_pointer interface represents one or more input devices,\n such as mice, which control the pointer location and pointer_focus\n of a seat.\n\n The wl_pointer interface generates motion, enter and leave\n events for the surfaces that the pointer is located over,\n and button and axis events for button presses, button releases\n and scrolling.\n @section page_iface_wl_pointer_api API\n See @ref iface_wl_pointer.\n/\n/**\n @defgroup iface_wl_pointer The wl_pointer interface\n\n The wl_pointer interface represents one or more input devices,\n such as mice, which control the pointer location and pointer_focus\n of a seat.\n\n The wl_pointer interface generates motion, enter and leave\n events for the surfaces that the pointer is located over,\n and button and axis events for button presses, button releases\n and scrolling."]
     pub static wl_pointer_interface: wl_interface;
 }
 extern "C" {
     #[doc = " @page page_iface_wl_keyboard wl_keyboard\n @section page_iface_wl_keyboard_desc Description\n\n The wl_keyboard interface represents one or more keyboards\n associated with a seat.\n @section page_iface_wl_keyboard_api API\n See @ref iface_wl_keyboard.\n/\n/**\n @defgroup iface_wl_keyboard The wl_keyboard interface\n\n The wl_keyboard interface represents one or more keyboards\n associated with a seat."]
     pub static wl_keyboard_interface: wl_interface;
 }
 extern "C" {
     #[doc = " @page page_iface_wl_touch wl_touch\n @section page_iface_wl_touch_desc Description\n\n The wl_touch interface represents a touchscreen\n associated with a seat.\n\n Touch interactions can consist of one or more contacts.\n For each contact, a series of events is generated, starting\n with a down event, followed by zero or more motion events,\n and ending with an up event. Events relating to the same\n contact point can be identified by the ID of the sequence.\n @section page_iface_wl_touch_api API\n See @ref iface_wl_touch.\n/\n/**\n @defgroup iface_wl_touch The wl_touch interface\n\n The wl_touch interface represents a touchscreen\n associated with a seat.\n\n Touch interactions can consist of one or more contacts.\n For each contact, a series of events is generated, starting\n with a down event, followed by zero or more motion events,\n and ending with an up event. Events relating to the same\n contact point can be identified by the ID of the sequence."]
     pub static wl_touch_interface: wl_interface;
 }
 extern "C" {
     #[doc = " @page page_iface_wl_output wl_output\n @section page_iface_wl_output_desc Description\n\n An output describes part of the compositor geometry.  The\n compositor works in the 'compositor coordinate system' and an\n output corresponds to a rectangular area in that space that is\n actually visible.  This typically corresponds to a monitor that\n displays part of the compositor space.  This object is published\n as global during start up, or when a monitor is hotplugged.\n @section page_iface_wl_output_api API\n See @ref iface_wl_output.\n/\n/**\n @defgroup iface_wl_output The wl_output interface\n\n An output describes part of the compositor geometry.  The\n compositor works in the 'compositor coordinate system' and an\n output corresponds to a rectangular area in that space that is\n actually visible.  This typically corresponds to a monitor that\n displays part of the compositor space.  This object is published\n as global during start up, or when a monitor is hotplugged."]
     pub static wl_output_interface: wl_interface;
 }
 extern "C" {
     #[doc = " @page page_iface_wl_region wl_region\n @section page_iface_wl_region_desc Description\n\n A region object describes an area.\n\n Region objects are used to describe the opaque and input\n regions of a surface.\n @section page_iface_wl_region_api API\n See @ref iface_wl_region.\n/\n/**\n @defgroup iface_wl_region The wl_region interface\n\n A region object describes an area.\n\n Region objects are used to describe the opaque and input\n regions of a surface."]
     pub static wl_region_interface: wl_interface;
 }
 extern "C" {
     #[doc = " @page page_iface_wl_subcompositor wl_subcompositor\n @section page_iface_wl_subcompositor_desc Description\n\n The global interface exposing sub-surface compositing capabilities.\n A wl_surface, that has sub-surfaces associated, is called the\n parent surface. Sub-surfaces can be arbitrarily nested and create\n a tree of sub-surfaces.\n\n The root surface in a tree of sub-surfaces is the main\n surface. The main surface cannot be a sub-surface, because\n sub-surfaces must always have a parent.\n\n A main surface with its sub-surfaces forms a (compound) window.\n For window management purposes, this set of wl_surface objects is\n to be considered as a single window, and it should also behave as\n such.\n\n The aim of sub-surfaces is to offload some of the compositing work\n within a window from clients to the compositor. A prime example is\n a video player with decorations and video in separate wl_surface\n objects. This should allow the compositor to pass YUV video buffer\n processing to dedicated overlay hardware when possible.\n @section page_iface_wl_subcompositor_api API\n See @ref iface_wl_subcompositor.\n/\n/**\n @defgroup iface_wl_subcompositor The wl_subcompositor interface\n\n The global interface exposing sub-surface compositing capabilities.\n A wl_surface, that has sub-surfaces associated, is called the\n parent surface. Sub-surfaces can be arbitrarily nested and create\n a tree of sub-surfaces.\n\n The root surface in a tree of sub-surfaces is the main\n surface. The main surface cannot be a sub-surface, because\n sub-surfaces must always have a parent.\n\n A main surface with its sub-surfaces forms a (compound) window.\n For window management purposes, this set of wl_surface objects is\n to be considered as a single window, and it should also behave as\n such.\n\n The aim of sub-surfaces is to offload some of the compositing work\n within a window from clients to the compositor. A prime example is\n a video player with decorations and video in separate wl_surface\n objects. This should allow the compositor to pass YUV video buffer\n processing to dedicated overlay hardware when possible."]
     pub static wl_subcompositor_interface: wl_interface;
 }
 extern "C" {
     #[doc = " @page page_iface_wl_subsurface wl_subsurface\n @section page_iface_wl_subsurface_desc Description\n\n An additional interface to a wl_surface object, which has been\n made a sub-surface. A sub-surface has one parent surface. A\n sub-surface's size and position are not limited to that of the parent.\n Particularly, a sub-surface is not automatically clipped to its\n parent's area.\n\n A sub-surface becomes mapped, when a non-NULL wl_buffer is applied\n and the parent surface is mapped. The order of which one happens\n first is irrelevant. A sub-surface is hidden if the parent becomes\n hidden, or if a NULL wl_buffer is applied. These rules apply\n recursively through the tree of surfaces.\n\n The behaviour of a wl_surface.commit request on a sub-surface\n depends on the sub-surface's mode. The possible modes are\n synchronized and desynchronized, see methods\n wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized\n mode caches the wl_surface state to be applied when the parent's\n state gets applied, and desynchronized mode applies the pending\n wl_surface state directly. A sub-surface is initially in the\n synchronized mode.\n\n Sub-surfaces also have another kind of state, which is managed by\n wl_subsurface requests, as opposed to wl_surface requests. This\n state includes the sub-surface position relative to the parent\n surface (wl_subsurface.set_position), and the stacking order of\n the parent and its sub-surfaces (wl_subsurface.place_above and\n .place_below). This state is applied when the parent surface's\n wl_surface state is applied, regardless of the sub-surface's mode.\n As the exception, set_sync and set_desync are effective immediately.\n\n The main surface can be thought to be always in desynchronized mode,\n since it does not have a parent in the sub-surfaces sense.\n\n Even if a sub-surface is in desynchronized mode, it will behave as\n in synchronized mode, if its parent surface behaves as in\n synchronized mode. This rule is applied recursively throughout the\n tree of surfaces. This means, that one can set a sub-surface into\n synchronized mode, and then assume that all its child and grand-child\n sub-surfaces are synchronized, too, without explicitly setting them.\n\n Destroying a sub-surface takes effect immediately. If you need to\n synchronize the removal of a sub-surface to the parent surface update,\n unmap the sub-surface first by attaching a NULL wl_buffer, update parent,\n and then destroy the sub-surface.\n\n If the parent wl_surface object is destroyed, the sub-surface is\n unmapped.\n @section page_iface_wl_subsurface_api API\n See @ref iface_wl_subsurface.\n/\n/**\n @defgroup iface_wl_subsurface The wl_subsurface interface\n\n An additional interface to a wl_surface object, which has been\n made a sub-surface. A sub-surface has one parent surface. A\n sub-surface's size and position are not limited to that of the parent.\n Particularly, a sub-surface is not automatically clipped to its\n parent's area.\n\n A sub-surface becomes mapped, when a non-NULL wl_buffer is applied\n and the parent surface is mapped. The order of which one happens\n first is irrelevant. A sub-surface is hidden if the parent becomes\n hidden, or if a NULL wl_buffer is applied. These rules apply\n recursively through the tree of surfaces.\n\n The behaviour of a wl_surface.commit request on a sub-surface\n depends on the sub-surface's mode. The possible modes are\n synchronized and desynchronized, see methods\n wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized\n mode caches the wl_surface state to be applied when the parent's\n state gets applied, and desynchronized mode applies the pending\n wl_surface state directly. A sub-surface is initially in the\n synchronized mode.\n\n Sub-surfaces also have another kind of state, which is managed by\n wl_subsurface requests, as opposed to wl_surface requests. This\n state includes the sub-surface position relative to the parent\n surface (wl_subsurface.set_position), and the stacking order of\n the parent and its sub-surfaces (wl_subsurface.place_above and\n .place_below). This state is applied when the parent surface's\n wl_surface state is applied, regardless of the sub-surface's mode.\n As the exception, set_sync and set_desync are effective immediately.\n\n The main surface can be thought to be always in desynchronized mode,\n since it does not have a parent in the sub-surfaces sense.\n\n Even if a sub-surface is in desynchronized mode, it will behave as\n in synchronized mode, if its parent surface behaves as in\n synchronized mode. This rule is applied recursively throughout the\n tree of surfaces. This means, that one can set a sub-surface into\n synchronized mode, and then assume that all its child and grand-child\n sub-surfaces are synchronized, too, without explicitly setting them.\n\n Destroying a sub-surface takes effect immediately. If you need to\n synchronize the removal of a sub-surface to the parent surface update,\n unmap the sub-surface first by attaching a NULL wl_buffer, update parent,\n and then destroy the sub-surface.\n\n If the parent wl_surface object is destroyed, the sub-surface is\n unmapped."]
     pub static wl_subsurface_interface: wl_interface;
 }
 #[doc = " server couldn't find object"]
 pub const wl_display_error_WL_DISPLAY_ERROR_INVALID_OBJECT: wl_display_error = 0;
 #[doc = " method doesn't exist on the specified interface or malformed request"]
 pub const wl_display_error_WL_DISPLAY_ERROR_INVALID_METHOD: wl_display_error = 1;
 #[doc = " server is out of memory"]
 pub const wl_display_error_WL_DISPLAY_ERROR_NO_MEMORY: wl_display_error = 2;
 #[doc = " implementation error in compositor"]
 pub const wl_display_error_WL_DISPLAY_ERROR_IMPLEMENTATION: wl_display_error = 3;
 #[doc = " @ingroup iface_wl_display\n global error values\n\n These errors are global and can be emitted in response to any\n server request."]
 pub type wl_display_error = ::std::os::raw::c_uint;
 #[doc = " @ingroup iface_wl_display\n @struct wl_display_listener"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_display_listener {
     #[doc = " fatal error event\n\n The error event is sent out when a fatal (non-recoverable)\n error has occurred. The object_id argument is the object where\n the error occurred, most often in response to a request to that\n object. The code identifies the error and is defined by the\n object interface. As such, each interface defines its own set of\n error codes. The message is a brief description of the error,\n for (debugging) convenience.\n @param object_id object where the error occurred\n @param code error code\n @param message error description"]
     pub error: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_display: *mut wl_display,
             object_id: *mut ::std::os::raw::c_void,
             code: u32,
             message: *const ::std::os::raw::c_char,
         ),
     >,
     #[doc = " acknowledge object ID deletion\n\n This event is used internally by the object ID management\n logic. When a client deletes an object that it had created, the\n server will send this event to acknowledge that it has seen the\n delete request. When the client receives this event, it will\n know that it can safely reuse the object ID.\n @param id deleted object ID"]
     pub delete_id: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_display: *mut wl_display,
             id: u32,
         ),
     >,
 }
 #[test]
 fn bindgen_test_layout_wl_display_listener() {
     const UNINIT: ::std::mem::MaybeUninit<wl_display_listener> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_display_listener>(),
         16usize,
         concat!("Size of: ", stringify!(wl_display_listener))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_display_listener>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_display_listener))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_display_listener),
             "::",
             stringify!(error)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).delete_id) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_display_listener),
             "::",
             stringify!(delete_id)
         )
     );
 }
#[doc = " @ingroup iface_wl_registry\n @struct wl_registry_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_registry_listener {
    #[doc = " announce global object\n\n Notify the client of global objects.\n\n The event notifies the client that a global object with the\n given name is now available, and it implements the given version\n of the given interface.\n @param name numeric name of the global object\n @param interface interface implemented by the object\n @param version interface version"]
    pub global: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_registry: *mut wl_registry,
            name: u32,
            interface: *const ::std::os::raw::c_char,
            version: u32,
        ),
    >,
    #[doc = " announce removal of global object\n\n Notify the client of removed global objects.\n\n This event notifies the client that the global identified by\n name is no longer available. If the client bound to the global\n using the bind request, the client should now destroy that\n object.\n\n The object remains valid and requests to the object will be\n ignored until the client destroys it, to avoid races between the\n global going away and a client sending a request to it.\n @param name numeric name of the global object"]
    pub global_remove: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_registry: *mut wl_registry,
            name: u32,
        ),
    >,
}
 #[test]
 fn bindgen_test_layout_wl_registry_listener() {
     const UNINIT: ::std::mem::MaybeUninit<wl_registry_listener> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_registry_listener>(),
         16usize,
         concat!("Size of: ", stringify!(wl_registry_listener))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_registry_listener>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_registry_listener))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).global) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_registry_listener),
             "::",
             stringify!(global)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).global_remove) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_registry_listener),
             "::",
             stringify!(global_remove)
         )
     );
 }
 #[doc = " @ingroup iface_wl_callback\n @struct wl_callback_listener"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_callback_listener {
     #[doc = " done event\n\n Notify the client when the related request is done.\n @param callback_data request-specific data for the callback"]
     pub done: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_callback: *mut wl_callback,
             callback_data: u32,
         ),
     >,
 }
 #[test]
 fn bindgen_test_layout_wl_callback_listener() {
     const UNINIT: ::std::mem::MaybeUninit<wl_callback_listener> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_callback_listener>(),
         8usize,
         concat!("Size of: ", stringify!(wl_callback_listener))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_callback_listener>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_callback_listener))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).done) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_callback_listener),
             "::",
             stringify!(done)
         )
     );
 }
 #[doc = " buffer format is not known"]
 pub const wl_shm_error_WL_SHM_ERROR_INVALID_FORMAT: wl_shm_error = 0;
 #[doc = " invalid size or stride during pool or buffer creation"]
 pub const wl_shm_error_WL_SHM_ERROR_INVALID_STRIDE: wl_shm_error = 1;
 #[doc = " mmapping the file descriptor failed"]
 pub const wl_shm_error_WL_SHM_ERROR_INVALID_FD: wl_shm_error = 2;
 #[doc = " @ingroup iface_wl_shm\n wl_shm error values\n\n These errors can be emitted in response to wl_shm requests."]
 pub type wl_shm_error = ::std::os::raw::c_uint;
 #[doc = " 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_ARGB8888: wl_shm_format = 0;
 #[doc = " 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_XRGB8888: wl_shm_format = 1;
 #[doc = " 8-bit color index format, [7:0] C"]
 pub const wl_shm_format_WL_SHM_FORMAT_C8: wl_shm_format = 538982467;
 #[doc = " 8-bit RGB format, [7:0] R:G:B 3:3:2"]
 pub const wl_shm_format_WL_SHM_FORMAT_RGB332: wl_shm_format = 943867730;
 #[doc = " 8-bit BGR format, [7:0] B:G:R 2:3:3"]
 pub const wl_shm_format_WL_SHM_FORMAT_BGR233: wl_shm_format = 944916290;
 #[doc = " 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_XRGB4444: wl_shm_format = 842093144;
 #[doc = " 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_XBGR4444: wl_shm_format = 842089048;
 #[doc = " 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_RGBX4444: wl_shm_format = 842094674;
 #[doc = " 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_BGRX4444: wl_shm_format = 842094658;
 #[doc = " 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_ARGB4444: wl_shm_format = 842093121;
 #[doc = " 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_ABGR4444: wl_shm_format = 842089025;
 #[doc = " 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_RGBA4444: wl_shm_format = 842088786;
 #[doc = " 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_BGRA4444: wl_shm_format = 842088770;
 #[doc = " 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_XRGB1555: wl_shm_format = 892424792;
 #[doc = " 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_XBGR1555: wl_shm_format = 892420696;
 #[doc = " 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_RGBX5551: wl_shm_format = 892426322;
 #[doc = " 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_BGRX5551: wl_shm_format = 892426306;
 #[doc = " 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_ARGB1555: wl_shm_format = 892424769;
 #[doc = " 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_ABGR1555: wl_shm_format = 892420673;
 #[doc = " 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_RGBA5551: wl_shm_format = 892420434;
 #[doc = " 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_BGRA5551: wl_shm_format = 892420418;
 #[doc = " 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_RGB565: wl_shm_format = 909199186;
 #[doc = " 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_BGR565: wl_shm_format = 909199170;
 #[doc = " 24-bit RGB format, [23:0] R:G:B little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_RGB888: wl_shm_format = 875710290;
 #[doc = " 24-bit BGR format, [23:0] B:G:R little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_BGR888: wl_shm_format = 875710274;
 #[doc = " 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_XBGR8888: wl_shm_format = 875709016;
 #[doc = " 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_RGBX8888: wl_shm_format = 875714642;
 #[doc = " 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_BGRX8888: wl_shm_format = 875714626;
 #[doc = " 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_ABGR8888: wl_shm_format = 875708993;
 #[doc = " 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_RGBA8888: wl_shm_format = 875708754;
 #[doc = " 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_BGRA8888: wl_shm_format = 875708738;
 #[doc = " 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_XRGB2101010: wl_shm_format = 808669784;
 #[doc = " 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_XBGR2101010: wl_shm_format = 808665688;
 #[doc = " 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_RGBX1010102: wl_shm_format = 808671314;
 #[doc = " 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_BGRX1010102: wl_shm_format = 808671298;
 #[doc = " 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_ARGB2101010: wl_shm_format = 808669761;
 #[doc = " 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_ABGR2101010: wl_shm_format = 808665665;
 #[doc = " 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_RGBA1010102: wl_shm_format = 808665426;
 #[doc = " 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_BGRA1010102: wl_shm_format = 808665410;
 #[doc = " packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_YUYV: wl_shm_format = 1448695129;
 #[doc = " packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_YVYU: wl_shm_format = 1431918169;
 #[doc = " packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_UYVY: wl_shm_format = 1498831189;
 #[doc = " packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_VYUY: wl_shm_format = 1498765654;
 #[doc = " packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_AYUV: wl_shm_format = 1448433985;
 #[doc = " 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane"]
 pub const wl_shm_format_WL_SHM_FORMAT_NV12: wl_shm_format = 842094158;
 #[doc = " 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane"]
 pub const wl_shm_format_WL_SHM_FORMAT_NV21: wl_shm_format = 825382478;
 #[doc = " 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane"]
 pub const wl_shm_format_WL_SHM_FORMAT_NV16: wl_shm_format = 909203022;
 #[doc = " 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane"]
 pub const wl_shm_format_WL_SHM_FORMAT_NV61: wl_shm_format = 825644622;
 #[doc = " 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes"]
 pub const wl_shm_format_WL_SHM_FORMAT_YUV410: wl_shm_format = 961959257;
 #[doc = " 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes"]
 pub const wl_shm_format_WL_SHM_FORMAT_YVU410: wl_shm_format = 961893977;
 #[doc = " 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes"]
 pub const wl_shm_format_WL_SHM_FORMAT_YUV411: wl_shm_format = 825316697;
 #[doc = " 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes"]
 pub const wl_shm_format_WL_SHM_FORMAT_YVU411: wl_shm_format = 825316953;
 #[doc = " 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes"]
 pub const wl_shm_format_WL_SHM_FORMAT_YUV420: wl_shm_format = 842093913;
 #[doc = " 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes"]
 pub const wl_shm_format_WL_SHM_FORMAT_YVU420: wl_shm_format = 842094169;
 #[doc = " 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes"]
 pub const wl_shm_format_WL_SHM_FORMAT_YUV422: wl_shm_format = 909202777;
 #[doc = " 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes"]
 pub const wl_shm_format_WL_SHM_FORMAT_YVU422: wl_shm_format = 909203033;
 #[doc = " 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes"]
 pub const wl_shm_format_WL_SHM_FORMAT_YUV444: wl_shm_format = 875713881;
 #[doc = " 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes"]
 pub const wl_shm_format_WL_SHM_FORMAT_YVU444: wl_shm_format = 875714137;
 #[doc = " [7:0] R"]
 pub const wl_shm_format_WL_SHM_FORMAT_R8: wl_shm_format = 538982482;
 #[doc = " [15:0] R little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_R16: wl_shm_format = 540422482;
 #[doc = " [15:0] R:G 8:8 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_RG88: wl_shm_format = 943212370;
 #[doc = " [15:0] G:R 8:8 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_GR88: wl_shm_format = 943215175;
 #[doc = " [31:0] R:G 16:16 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_RG1616: wl_shm_format = 842221394;
 #[doc = " [31:0] G:R 16:16 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_GR1616: wl_shm_format = 842224199;
 #[doc = " [63:0] x:R:G:B 16:16:16:16 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_XRGB16161616F: wl_shm_format = 1211388504;
 #[doc = " [63:0] x:B:G:R 16:16:16:16 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_XBGR16161616F: wl_shm_format = 1211384408;
 #[doc = " [63:0] A:R:G:B 16:16:16:16 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_ARGB16161616F: wl_shm_format = 1211388481;
 #[doc = " [63:0] A:B:G:R 16:16:16:16 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_ABGR16161616F: wl_shm_format = 1211384385;
 #[doc = " [31:0] X:Y:Cb:Cr 8:8:8:8 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_XYUV8888: wl_shm_format = 1448434008;
 #[doc = " [23:0] Cr:Cb:Y 8:8:8 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_VUY888: wl_shm_format = 875713878;
 #[doc = " Y followed by U then V, 10:10:10. Non-linear modifier only"]
 pub const wl_shm_format_WL_SHM_FORMAT_VUY101010: wl_shm_format = 808670550;
 #[doc = " [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels"]
 pub const wl_shm_format_WL_SHM_FORMAT_Y210: wl_shm_format = 808530521;
 #[doc = " [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels"]
 pub const wl_shm_format_WL_SHM_FORMAT_Y212: wl_shm_format = 842084953;
 #[doc = " [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels"]
 pub const wl_shm_format_WL_SHM_FORMAT_Y216: wl_shm_format = 909193817;
 #[doc = " [31:0] A:Cr:Y:Cb 2:10:10:10 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_Y410: wl_shm_format = 808531033;
 #[doc = " [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_Y412: wl_shm_format = 842085465;
 #[doc = " [63:0] A:Cr:Y:Cb 16:16:16:16 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_Y416: wl_shm_format = 909194329;
 #[doc = " [31:0] X:Cr:Y:Cb 2:10:10:10 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_XVYU2101010: wl_shm_format = 808670808;
 #[doc = " [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_XVYU12_16161616: wl_shm_format = 909334104;
 #[doc = " [63:0] X:Cr:Y:Cb 16:16:16:16 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_XVYU16161616: wl_shm_format = 942954072;
 #[doc = " [63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_Y0L0: wl_shm_format = 810299481;
 #[doc = " [63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_X0L0: wl_shm_format = 810299480;
 #[doc = " [63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_Y0L2: wl_shm_format = 843853913;
 #[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_X0L2: wl_shm_format = 843853912;
 #[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_YUV420_8BIT: wl_shm_format = 942691673;
 #[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_YUV420_10BIT: wl_shm_format = 808539481;
 #[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_XRGB8888_A8: wl_shm_format = 943805016;
 #[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_XBGR8888_A8: wl_shm_format = 943800920;
 #[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_RGBX8888_A8: wl_shm_format = 943806546;
 #[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_BGRX8888_A8: wl_shm_format = 943806530;
 #[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_RGB888_A8: wl_shm_format = 943798354;
 #[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_BGR888_A8: wl_shm_format = 943798338;
 #[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_RGB565_A8: wl_shm_format = 943797586;
 #[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_BGR565_A8: wl_shm_format = 943797570;
 #[doc = " non-subsampled Cr:Cb plane"]
 pub const wl_shm_format_WL_SHM_FORMAT_NV24: wl_shm_format = 875714126;
 #[doc = " non-subsampled Cb:Cr plane"]
 pub const wl_shm_format_WL_SHM_FORMAT_NV42: wl_shm_format = 842290766;
 #[doc = " 2x1 subsampled Cr:Cb plane, 10 bit per channel"]
 pub const wl_shm_format_WL_SHM_FORMAT_P210: wl_shm_format = 808530512;
 #[doc = " 2x2 subsampled Cr:Cb plane 10 bits per channel"]
 pub const wl_shm_format_WL_SHM_FORMAT_P010: wl_shm_format = 808530000;
 #[doc = " 2x2 subsampled Cr:Cb plane 12 bits per channel"]
 pub const wl_shm_format_WL_SHM_FORMAT_P012: wl_shm_format = 842084432;
 #[doc = " 2x2 subsampled Cr:Cb plane 16 bits per channel"]
 pub const wl_shm_format_WL_SHM_FORMAT_P016: wl_shm_format = 909193296;
 #[doc = " [63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_AXBXGXRX106106106106: wl_shm_format = 808534593;
 #[doc = " 2x2 subsampled Cr:Cb plane"]
 pub const wl_shm_format_WL_SHM_FORMAT_NV15: wl_shm_format = 892425806;
 #[doc = " 2x2 subsampled Cr:Cb plane"]
 pub const wl_shm_format_WL_SHM_FORMAT_Q410: wl_shm_format = 808531025;
 #[doc = " 2x2 subsampled Cr:Cb plane"]
 pub const wl_shm_format_WL_SHM_FORMAT_Q401: wl_shm_format = 825242705;
 #[doc = " [63:0] x:R:G:B 16:16:16:16 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_XRGB16161616: wl_shm_format = 942953048;
 #[doc = " [63:0] x:B:G:R 16:16:16:16 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_XBGR16161616: wl_shm_format = 942948952;
 #[doc = " [63:0] A:R:G:B 16:16:16:16 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_ARGB16161616: wl_shm_format = 942953025;
 #[doc = " [63:0] A:B:G:R 16:16:16:16 little endian"]
 pub const wl_shm_format_WL_SHM_FORMAT_ABGR16161616: wl_shm_format = 942948929;
 #[doc = " @ingroup iface_wl_shm\n pixel formats\n\n This describes the memory layout of an individual pixel.\n\n All renderers should support argb8888 and xrgb8888 but any other\n formats are optional and may not be supported by the particular\n renderer in use.\n\n The drm format codes match the macros defined in drm_fourcc.h, except\n argb8888 and xrgb8888. The formats actually supported by the compositor\n will be reported by the format event.\n\n For all wl_shm formats and unless specified in another protocol\n extension, pre-multiplied alpha is used for pixel values."]
 pub type wl_shm_format = ::std::os::raw::c_uint;
 #[doc = " @ingroup iface_wl_shm\n @struct wl_shm_listener"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_shm_listener {
     #[doc = " pixel format description\n\n Informs the client about a valid pixel format that can be used\n for buffers. Known formats include argb8888 and xrgb8888.\n @param format buffer pixel format"]
     pub format: ::std::option::Option<
         unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, wl_shm: *mut wl_shm, format: u32),
     >,
 }
 #[test]
 fn bindgen_test_layout_wl_shm_listener() {
     const UNINIT: ::std::mem::MaybeUninit<wl_shm_listener> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_shm_listener>(),
         8usize,
         concat!("Size of: ", stringify!(wl_shm_listener))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_shm_listener>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_shm_listener))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_shm_listener),
             "::",
             stringify!(format)
         )
     );
 }
 #[doc = " @ingroup iface_wl_buffer\n @struct wl_buffer_listener"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_buffer_listener {
     #[doc = " compositor releases buffer\n\n Sent when this wl_buffer is no longer used by the compositor.\n The client is now free to reuse or destroy this buffer and its\n backing storage.\n\n If a client receives a release event before the frame callback\n requested in the same wl_surface.commit that attaches this\n wl_buffer to a surface, then the client is immediately free to\n reuse the buffer and its backing storage, and does not need a\n second buffer for the next surface content update. Typically\n this is possible, when the compositor maintains a copy of the\n wl_surface contents, e.g. as a GL texture. This is an important\n optimization for GL(ES) compositors with wl_shm clients."]
     pub release: ::std::option::Option<
         unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, wl_buffer: *mut wl_buffer),
     >,
 }
 #[test]
 fn bindgen_test_layout_wl_buffer_listener() {
     const UNINIT: ::std::mem::MaybeUninit<wl_buffer_listener> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_buffer_listener>(),
         8usize,
         concat!("Size of: ", stringify!(wl_buffer_listener))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_buffer_listener>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_buffer_listener))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_buffer_listener),
             "::",
             stringify!(release)
         )
     );
 }
 #[doc = " finish request was called untimely"]
 pub const wl_data_offer_error_WL_DATA_OFFER_ERROR_INVALID_FINISH: wl_data_offer_error = 0;
 #[doc = " action mask contains invalid values"]
 pub const wl_data_offer_error_WL_DATA_OFFER_ERROR_INVALID_ACTION_MASK: wl_data_offer_error = 1;
 #[doc = " action argument has an invalid value"]
 pub const wl_data_offer_error_WL_DATA_OFFER_ERROR_INVALID_ACTION: wl_data_offer_error = 2;
 #[doc = " offer doesn't accept this request"]
 pub const wl_data_offer_error_WL_DATA_OFFER_ERROR_INVALID_OFFER: wl_data_offer_error = 3;
 pub type wl_data_offer_error = ::std::os::raw::c_uint;
 #[doc = " @ingroup iface_wl_data_offer\n @struct wl_data_offer_listener"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_data_offer_listener {
     #[doc = " advertise offered mime type\n\n Sent immediately after creating the wl_data_offer object. One\n event per offered mime type.\n @param mime_type offered mime type"]
     pub offer: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_data_offer: *mut wl_data_offer,
             mime_type: *const ::std::os::raw::c_char,
         ),
     >,
     #[doc = " notify the source-side available actions\n\n This event indicates the actions offered by the data source.\n It will be sent immediately after creating the wl_data_offer\n object, or anytime the source side changes its offered actions\n through wl_data_source.set_actions.\n @param source_actions actions offered by the data source\n @since 3"]
     pub source_actions: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_data_offer: *mut wl_data_offer,
             source_actions: u32,
         ),
     >,
     #[doc = " notify the selected action\n\n This event indicates the action selected by the compositor\n after matching the source/destination side actions. Only one\n action (or none) will be offered here.\n\n This event can be emitted multiple times during the\n drag-and-drop operation in response to destination side action\n changes through wl_data_offer.set_actions.\n\n This event will no longer be emitted after wl_data_device.drop\n happened on the drag-and-drop destination, the client must honor\n the last action received, or the last preferred one set through\n wl_data_offer.set_actions when handling an \"ask\" action.\n\n Compositors may also change the selected action on the fly,\n mainly in response to keyboard modifier changes during the\n drag-and-drop operation.\n\n The most recent action received is always the valid one. Prior\n to receiving wl_data_device.drop, the chosen action may change\n (e.g. due to keyboard modifiers being pressed). At the time of\n receiving wl_data_device.drop the drag-and-drop destination must\n honor the last action received.\n\n Action changes may still happen after wl_data_device.drop,\n especially on \"ask\" actions, where the drag-and-drop destination\n may choose another action afterwards. Action changes happening\n at this stage are always the result of inter-client negotiation,\n the compositor shall no longer be able to induce a different\n action.\n\n Upon \"ask\" actions, it is expected that the drag-and-drop\n destination may potentially choose a different action and/or\n mime type, based on wl_data_offer.source_actions and finally\n chosen by the user (e.g. popping up a menu with the available\n options). The final wl_data_offer.set_actions and\n wl_data_offer.accept requests must happen before the call to\n wl_data_offer.finish.\n @param dnd_action action selected by the compositor\n @since 3"]
     pub action: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_data_offer: *mut wl_data_offer,
             dnd_action: u32,
         ),
     >,
 }
 #[test]
 fn bindgen_test_layout_wl_data_offer_listener() {
     const UNINIT: ::std::mem::MaybeUninit<wl_data_offer_listener> =
         ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_data_offer_listener>(),
         24usize,
         concat!("Size of: ", stringify!(wl_data_offer_listener))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_data_offer_listener>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_data_offer_listener))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).offer) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_data_offer_listener),
             "::",
             stringify!(offer)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).source_actions) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_data_offer_listener),
             "::",
             stringify!(source_actions)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
         16usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_data_offer_listener),
             "::",
             stringify!(action)
         )
     );
 }
 #[doc = " action mask contains invalid values"]
 pub const wl_data_source_error_WL_DATA_SOURCE_ERROR_INVALID_ACTION_MASK: wl_data_source_error = 0;
 #[doc = " source doesn't accept this request"]
 pub const wl_data_source_error_WL_DATA_SOURCE_ERROR_INVALID_SOURCE: wl_data_source_error = 1;
 pub type wl_data_source_error = ::std::os::raw::c_uint;
 #[doc = " @ingroup iface_wl_data_source\n @struct wl_data_source_listener"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_data_source_listener {
     #[doc = " a target accepts an offered mime type\n\n Sent when a target accepts pointer_focus or motion events. If\n a target does not accept any of the offered types, type is NULL.\n\n Used for feedback during drag-and-drop.\n @param mime_type mime type accepted by the target"]
     pub target: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_data_source: *mut wl_data_source,
             mime_type: *const ::std::os::raw::c_char,
         ),
     >,
     #[doc = " send the data\n\n Request for data from the client. Send the data as the\n specified mime type over the passed file descriptor, then close\n it.\n @param mime_type mime type for the data\n @param fd file descriptor for the data"]
     pub send: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_data_source: *mut wl_data_source,
             mime_type: *const ::std::os::raw::c_char,
             fd: i32,
         ),
     >,
     #[doc = " selection was cancelled\n\n This data source is no longer valid. There are several reasons\n why this could happen:\n\n - The data source has been replaced by another data source. -\n The drag-and-drop operation was performed, but the drop\n destination did not accept any of the mime types offered through\n wl_data_source.target. - The drag-and-drop operation was\n performed, but the drop destination did not select any of the\n actions present in the mask offered through\n wl_data_source.action. - The drag-and-drop operation was\n performed but didn't happen over a surface. - The compositor\n cancelled the drag-and-drop operation (e.g. compositor dependent\n timeouts to avoid stale drag-and-drop transfers).\n\n The client should clean up and destroy this data source.\n\n For objects of version 2 or older, wl_data_source.cancelled will\n only be emitted if the data source was replaced by another data\n source."]
     pub cancelled: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_data_source: *mut wl_data_source,
         ),
     >,
     #[doc = " the drag-and-drop operation physically finished\n\n The user performed the drop action. This event does not\n indicate acceptance, wl_data_source.cancelled may still be\n emitted afterwards if the drop destination does not accept any\n mime type.\n\n However, this event might however not be received if the\n compositor cancelled the drag-and-drop operation before this\n event could happen.\n\n Note that the data_source may still be used in the future and\n should not be destroyed here.\n @since 3"]
     pub dnd_drop_performed: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_data_source: *mut wl_data_source,
         ),
     >,
     #[doc = " the drag-and-drop operation concluded\n\n The drop destination finished interoperating with this data\n source, so the client is now free to destroy this data source\n and free all associated data.\n\n If the action used to perform the operation was \"move\", the\n source can now delete the transferred data.\n @since 3"]
     pub dnd_finished: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_data_source: *mut wl_data_source,
         ),
     >,
     #[doc = " notify the selected action\n\n This event indicates the action selected by the compositor\n after matching the source/destination side actions. Only one\n action (or none) will be offered here.\n\n This event can be emitted multiple times during the\n drag-and-drop operation, mainly in response to destination side\n changes through wl_data_offer.set_actions, and as the data\n device enters/leaves surfaces.\n\n It is only possible to receive this event after\n wl_data_source.dnd_drop_performed if the drag-and-drop operation\n ended in an \"ask\" action, in which case the final\n wl_data_source.action event will happen immediately before\n wl_data_source.dnd_finished.\n\n Compositors may also change the selected action on the fly,\n mainly in response to keyboard modifier changes during the\n drag-and-drop operation.\n\n The most recent action received is always the valid one. The\n chosen action may change alongside negotiation (e.g. an \"ask\"\n action can turn into a \"move\" operation), so the effects of the\n final action must always be applied in\n wl_data_offer.dnd_finished.\n\n Clients can trigger cursor surface changes from this point, so\n they reflect the current action.\n @param dnd_action action selected by the compositor\n @since 3"]
     pub action: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_data_source: *mut wl_data_source,
             dnd_action: u32,
         ),
     >,
 }
 #[test]
 fn bindgen_test_layout_wl_data_source_listener() {
     const UNINIT: ::std::mem::MaybeUninit<wl_data_source_listener> =
         ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_data_source_listener>(),
         48usize,
         concat!("Size of: ", stringify!(wl_data_source_listener))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_data_source_listener>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_data_source_listener))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_data_source_listener),
             "::",
             stringify!(target)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).send) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_data_source_listener),
             "::",
             stringify!(send)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).cancelled) as usize - ptr as usize },
         16usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_data_source_listener),
             "::",
             stringify!(cancelled)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).dnd_drop_performed) as usize - ptr as usize },
         24usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_data_source_listener),
             "::",
             stringify!(dnd_drop_performed)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).dnd_finished) as usize - ptr as usize },
         32usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_data_source_listener),
             "::",
             stringify!(dnd_finished)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
         40usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_data_source_listener),
             "::",
             stringify!(action)
         )
     );
 }
 #[doc = " given wl_surface has another role"]
 pub const wl_data_device_error_WL_DATA_DEVICE_ERROR_ROLE: wl_data_device_error = 0;
 pub type wl_data_device_error = ::std::os::raw::c_uint;
 #[doc = " @ingroup iface_wl_data_device\n @struct wl_data_device_listener"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_data_device_listener {
     #[doc = " introduce a new wl_data_offer\n\n The data_offer event introduces a new wl_data_offer object,\n which will subsequently be used in either the data_device.enter\n event (for drag-and-drop) or the data_device.selection event\n (for selections). Immediately following the\n data_device.data_offer event, the new data_offer object will\n send out data_offer.offer events to describe the mime types it\n offers.\n @param id the new data_offer object"]
     pub data_offer: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_data_device: *mut wl_data_device,
             id: *mut wl_data_offer,
         ),
     >,
     #[doc = " initiate drag-and-drop session\n\n This event is sent when an active drag-and-drop pointer enters\n a surface owned by the client. The position of the pointer at\n enter time is provided by the x and y arguments, in\n surface-local coordinates.\n @param serial serial number of the enter event\n @param surface client surface entered\n @param x surface-local x coordinate\n @param y surface-local y coordinate\n @param id source data_offer object"]
     pub enter: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_data_device: *mut wl_data_device,
             serial: u32,
             surface: *mut wl_surface,
             x: wl_fixed_t,
             y: wl_fixed_t,
             id: *mut wl_data_offer,
         ),
     >,
     #[doc = " end drag-and-drop session\n\n This event is sent when the drag-and-drop pointer leaves the\n surface and the session ends. The client must destroy the\n wl_data_offer introduced at enter time at this point."]
     pub leave: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_data_device: *mut wl_data_device,
         ),
     >,
     #[doc = " drag-and-drop session motion\n\n This event is sent when the drag-and-drop pointer moves within\n the currently focused surface. The new position of the pointer\n is provided by the x and y arguments, in surface-local\n coordinates.\n @param time timestamp with millisecond granularity\n @param x surface-local x coordinate\n @param y surface-local y coordinate"]
     pub motion: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_data_device: *mut wl_data_device,
             time: u32,
             x: wl_fixed_t,
             y: wl_fixed_t,
         ),
     >,
     #[doc = " end drag-and-drop session successfully\n\n The event is sent when a drag-and-drop operation is ended\n because the implicit grab is removed.\n\n The drag-and-drop destination is expected to honor the last\n action received through wl_data_offer.action, if the resulting\n action is \"copy\" or \"move\", the destination can still perform\n wl_data_offer.receive requests, and is expected to end all\n transfers with a wl_data_offer.finish request.\n\n If the resulting action is \"ask\", the action will not be\n considered final. The drag-and-drop destination is expected to\n perform one last wl_data_offer.set_actions request, or\n wl_data_offer.destroy in order to cancel the operation."]
     pub drop: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_data_device: *mut wl_data_device,
         ),
     >,
     #[doc = " advertise new selection\n\n The selection event is sent out to notify the client of a new\n wl_data_offer for the selection for this device. The\n data_device.data_offer and the data_offer.offer events are sent\n out immediately before this event to introduce the data offer\n object. The selection event is sent to a client immediately\n before receiving keyboard focus and when a new selection is set\n while the client has keyboard focus. The data_offer is valid\n until a new data_offer or NULL is received or until the client\n loses keyboard focus. Switching surface with keyboard focus\n within the same client doesn't mean a new selection will be\n sent. The client must destroy the previous selection data_offer,\n if any, upon receiving this event.\n @param id selection data_offer object"]
     pub selection: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_data_device: *mut wl_data_device,
             id: *mut wl_data_offer,
         ),
     >,
 }
 #[test]
 fn bindgen_test_layout_wl_data_device_listener() {
     const UNINIT: ::std::mem::MaybeUninit<wl_data_device_listener> =
         ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_data_device_listener>(),
         48usize,
         concat!("Size of: ", stringify!(wl_data_device_listener))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_data_device_listener>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_data_device_listener))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).data_offer) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_data_device_listener),
             "::",
             stringify!(data_offer)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).enter) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_data_device_listener),
             "::",
             stringify!(enter)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).leave) as usize - ptr as usize },
         16usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_data_device_listener),
             "::",
             stringify!(leave)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).motion) as usize - ptr as usize },
         24usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_data_device_listener),
             "::",
             stringify!(motion)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).drop) as usize - ptr as usize },
         32usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_data_device_listener),
             "::",
             stringify!(drop)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).selection) as usize - ptr as usize },
         40usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_data_device_listener),
             "::",
             stringify!(selection)
         )
     );
 }
 #[doc = " no action"]
 pub const wl_data_device_manager_dnd_action_WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE:
     wl_data_device_manager_dnd_action = 0;
 #[doc = " copy action"]
 pub const wl_data_device_manager_dnd_action_WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY:
     wl_data_device_manager_dnd_action = 1;
 #[doc = " move action"]
 pub const wl_data_device_manager_dnd_action_WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE:
     wl_data_device_manager_dnd_action = 2;
 #[doc = " ask action"]
 pub const wl_data_device_manager_dnd_action_WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK:
     wl_data_device_manager_dnd_action = 4;
 #[doc = " @ingroup iface_wl_data_device_manager\n drag and drop actions\n\n This is a bitmask of the available/preferred actions in a\n drag-and-drop operation.\n\n In the compositor, the selected action is a result of matching the\n actions offered by the source and destination sides.  \"action\" events\n with a \"none\" action will be sent to both source and destination if\n there is no match. All further checks will effectively happen on\n (source actions  destination actions).\n\n In addition, compositors may also pick different actions in\n reaction to key modifiers being pressed. One common design that\n is used in major toolkits (and the behavior recommended for\n compositors) is:\n\n - If no modifiers are pressed, the first match (in bit order)\n will be used.\n - Pressing Shift selects \"move\", if enabled in the mask.\n - Pressing Control selects \"copy\", if enabled in the mask.\n\n Behavior beyond that is considered implementation-dependent.\n Compositors may for example bind other modifiers (like Alt/Meta)\n or drags initiated with other buttons than BTN_LEFT to specific\n actions (e.g. \"ask\")."]
 pub type wl_data_device_manager_dnd_action = ::std::os::raw::c_uint;
 #[doc = " given wl_surface has another role"]
 pub const wl_shell_error_WL_SHELL_ERROR_ROLE: wl_shell_error = 0;
 pub type wl_shell_error = ::std::os::raw::c_uint;
 #[doc = " no edge"]
 pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_NONE: wl_shell_surface_resize = 0;
 #[doc = " top edge"]
 pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_TOP: wl_shell_surface_resize = 1;
 #[doc = " bottom edge"]
 pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_BOTTOM: wl_shell_surface_resize = 2;
 #[doc = " left edge"]
 pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_LEFT: wl_shell_surface_resize = 4;
 #[doc = " top and left edges"]
 pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_TOP_LEFT: wl_shell_surface_resize = 5;
 #[doc = " bottom and left edges"]
 pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_BOTTOM_LEFT: wl_shell_surface_resize = 6;
 #[doc = " right edge"]
 pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_RIGHT: wl_shell_surface_resize = 8;
 #[doc = " top and right edges"]
 pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_TOP_RIGHT: wl_shell_surface_resize = 9;
 #[doc = " bottom and right edges"]
 pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_BOTTOM_RIGHT: wl_shell_surface_resize =
     10;
 #[doc = " @ingroup iface_wl_shell_surface\n edge values for resizing\n\n These values are used to indicate which edge of a surface\n is being dragged in a resize operation. The server may\n use this information to adapt its behavior, e.g. choose\n an appropriate cursor image."]
 pub type wl_shell_surface_resize = ::std::os::raw::c_uint;
 #[doc = " do not set keyboard focus"]
 pub const wl_shell_surface_transient_WL_SHELL_SURFACE_TRANSIENT_INACTIVE:
     wl_shell_surface_transient = 1;
 #[doc = " @ingroup iface_wl_shell_surface\n details of transient behaviour\n\n These flags specify details of the expected behaviour\n of transient surfaces. Used in the set_transient request."]
 pub type wl_shell_surface_transient = ::std::os::raw::c_uint;
 #[doc = " no preference, apply default policy"]
 pub const wl_shell_surface_fullscreen_method_WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT:
     wl_shell_surface_fullscreen_method = 0;
 #[doc = " scale, preserve the surface's aspect ratio and center on output"]
 pub const wl_shell_surface_fullscreen_method_WL_SHELL_SURFACE_FULLSCREEN_METHOD_SCALE:
     wl_shell_surface_fullscreen_method = 1;
 #[doc = " switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch"]
 pub const wl_shell_surface_fullscreen_method_WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER:
     wl_shell_surface_fullscreen_method = 2;
 #[doc = " no upscaling, center on output and add black borders to compensate size mismatch"]
 pub const wl_shell_surface_fullscreen_method_WL_SHELL_SURFACE_FULLSCREEN_METHOD_FILL:
     wl_shell_surface_fullscreen_method = 3;
 #[doc = " @ingroup iface_wl_shell_surface\n different method to set the surface fullscreen\n\n Hints to indicate to the compositor how to deal with a conflict\n between the dimensions of the surface and the dimensions of the\n output. The compositor is free to ignore this parameter."]
 pub type wl_shell_surface_fullscreen_method = ::std::os::raw::c_uint;
 #[doc = " @ingroup iface_wl_shell_surface\n @struct wl_shell_surface_listener"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_shell_surface_listener {
     #[doc = " ping client\n\n Ping a client to check if it is receiving events and sending\n requests. A client is expected to reply with a pong request.\n @param serial serial number of the ping"]
     pub ping: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_shell_surface: *mut wl_shell_surface,
             serial: u32,
         ),
     >,
     #[doc = " suggest resize\n\n The configure event asks the client to resize its surface.\n\n The size is a hint, in the sense that the client is free to\n ignore it if it doesn't resize, pick a smaller size (to satisfy\n aspect ratio or resize in steps of NxM pixels).\n\n The edges parameter provides a hint about how the surface was\n resized. The client may use this information to decide how to\n adjust its content to the new size (e.g. a scrolling area might\n adjust its content position to leave the viewable content\n unmoved).\n\n The client is free to dismiss all but the last configure event\n it received.\n\n The width and height arguments specify the size of the window in\n surface-local coordinates.\n @param edges how the surface was resized\n @param width new width of the surface\n @param height new height of the surface"]
     pub configure: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_shell_surface: *mut wl_shell_surface,
             edges: u32,
             width: i32,
             height: i32,
         ),
     >,
     #[doc = " popup interaction is done\n\n The popup_done event is sent out when a popup grab is broken,\n that is, when the user clicks a surface that doesn't belong to\n the client owning the popup surface."]
     pub popup_done: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_shell_surface: *mut wl_shell_surface,
         ),
     >,
 }
 #[test]
 fn bindgen_test_layout_wl_shell_surface_listener() {
     const UNINIT: ::std::mem::MaybeUninit<wl_shell_surface_listener> =
         ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_shell_surface_listener>(),
         24usize,
         concat!("Size of: ", stringify!(wl_shell_surface_listener))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_shell_surface_listener>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_shell_surface_listener))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).ping) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_shell_surface_listener),
             "::",
             stringify!(ping)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).configure) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_shell_surface_listener),
             "::",
             stringify!(configure)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).popup_done) as usize - ptr as usize },
         16usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_shell_surface_listener),
             "::",
             stringify!(popup_done)
         )
     );
 }
 #[doc = " buffer scale value is invalid"]
 pub const wl_surface_error_WL_SURFACE_ERROR_INVALID_SCALE: wl_surface_error = 0;
 #[doc = " buffer transform value is invalid"]
 pub const wl_surface_error_WL_SURFACE_ERROR_INVALID_TRANSFORM: wl_surface_error = 1;
 #[doc = " buffer size is invalid"]
 pub const wl_surface_error_WL_SURFACE_ERROR_INVALID_SIZE: wl_surface_error = 2;
 #[doc = " buffer offset is invalid"]
 pub const wl_surface_error_WL_SURFACE_ERROR_INVALID_OFFSET: wl_surface_error = 3;
 #[doc = " surface was destroyed before its role object"]
 pub const wl_surface_error_WL_SURFACE_ERROR_DEFUNCT_ROLE_OBJECT: wl_surface_error = 4;
 #[doc = " @ingroup iface_wl_surface\n wl_surface error values\n\n These errors can be emitted in response to wl_surface requests."]
 pub type wl_surface_error = ::std::os::raw::c_uint;
 #[doc = " @ingroup iface_wl_surface\n @struct wl_surface_listener"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_surface_listener {
     #[doc = " surface enters an output\n\n This is emitted whenever a surface's creation, movement, or\n resizing results in some part of it being within the scanout\n region of an output.\n\n Note that a surface may be overlapping with zero or more\n outputs.\n @param output output entered by the surface"]
     pub enter: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_surface: *mut wl_surface,
             output: *mut wl_output,
         ),
     >,
     #[doc = " surface leaves an output\n\n This is emitted whenever a surface's creation, movement, or\n resizing results in it no longer having any part of it within\n the scanout region of an output.\n\n Clients should not use the number of outputs the surface is on\n for frame throttling purposes. The surface might be hidden even\n if no leave event has been sent, and the compositor might expect\n new surface content updates even if no enter event has been\n sent. The frame event should be used instead.\n @param output output left by the surface"]
     pub leave: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_surface: *mut wl_surface,
             output: *mut wl_output,
         ),
     >,
     #[doc = " preferred buffer scale for the surface\n\n This event indicates the preferred buffer scale for this\n surface. It is sent whenever the compositor's preference\n changes.\n\n It is intended that scaling aware clients use this event to\n scale their content and use wl_surface.set_buffer_scale to\n indicate the scale they have rendered with. This allows clients\n to supply a higher detail buffer.\n @param factor preferred scaling factor\n @since 6"]
     pub preferred_buffer_scale: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_surface: *mut wl_surface,
             factor: i32,
         ),
     >,
     #[doc = " preferred buffer transform for the surface\n\n This event indicates the preferred buffer transform for this\n surface. It is sent whenever the compositor's preference\n changes.\n\n It is intended that transform aware clients use this event to\n apply the transform to their content and use\n wl_surface.set_buffer_transform to indicate the transform they\n have rendered with.\n @param transform preferred transform\n @since 6"]
     pub preferred_buffer_transform: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_surface: *mut wl_surface,
             transform: u32,
         ),
     >,
 }
 #[test]
 fn bindgen_test_layout_wl_surface_listener() {
     const UNINIT: ::std::mem::MaybeUninit<wl_surface_listener> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_surface_listener>(),
         32usize,
         concat!("Size of: ", stringify!(wl_surface_listener))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_surface_listener>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_surface_listener))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).enter) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_surface_listener),
             "::",
             stringify!(enter)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).leave) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_surface_listener),
             "::",
             stringify!(leave)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).preferred_buffer_scale) as usize - ptr as usize },
         16usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_surface_listener),
             "::",
             stringify!(preferred_buffer_scale)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).preferred_buffer_transform) as usize - ptr as usize },
         24usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_surface_listener),
             "::",
             stringify!(preferred_buffer_transform)
         )
     );
 }
 #[doc = " the seat has pointer devices"]
 pub const wl_seat_capability_WL_SEAT_CAPABILITY_POINTER: wl_seat_capability = 1;
 #[doc = " the seat has one or more keyboards"]
 pub const wl_seat_capability_WL_SEAT_CAPABILITY_KEYBOARD: wl_seat_capability = 2;
 #[doc = " the seat has touch devices"]
 pub const wl_seat_capability_WL_SEAT_CAPABILITY_TOUCH: wl_seat_capability = 4;
 #[doc = " @ingroup iface_wl_seat\n seat capability bitmask\n\n This is a bitmask of capabilities this seat has; if a member is\n set, then it is present on the seat."]
 pub type wl_seat_capability = ::std::os::raw::c_uint;
 #[doc = " get_pointer, get_keyboard or get_touch called on seat without the matching capability"]
 pub const wl_seat_error_WL_SEAT_ERROR_MISSING_CAPABILITY: wl_seat_error = 0;
 #[doc = " @ingroup iface_wl_seat\n wl_seat error values\n\n These errors can be emitted in response to wl_seat requests."]
 pub type wl_seat_error = ::std::os::raw::c_uint;
 #[doc = " @ingroup iface_wl_seat\n @struct wl_seat_listener"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_seat_listener {
     #[doc = " seat capabilities changed\n\n This is emitted whenever a seat gains or loses the pointer,\n keyboard or touch capabilities. The argument is a capability\n enum containing the complete set of capabilities this seat has.\n\n When the pointer capability is added, a client may create a\n wl_pointer object using the wl_seat.get_pointer request. This\n object will receive pointer events until the capability is\n removed in the future.\n\n When the pointer capability is removed, a client should destroy\n the wl_pointer objects associated with the seat where the\n capability was removed, using the wl_pointer.release request. No\n further pointer events will be received on these objects.\n\n In some compositors, if a seat regains the pointer capability\n and a client has a previously obtained wl_pointer object of\n version 4 or less, that object may start sending pointer events\n again. This behavior is considered a misinterpretation of the\n intended behavior and must not be relied upon by the client.\n wl_pointer objects of version 5 or later must not send events if\n created before the most recent event notifying the client of an\n added pointer capability.\n\n The above behavior also applies to wl_keyboard and wl_touch with\n the keyboard and touch capabilities, respectively.\n @param capabilities capabilities of the seat"]
     pub capabilities: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_seat: *mut wl_seat,
             capabilities: u32,
         ),
     >,
     #[doc = " unique identifier for this seat\n\n In a multi-seat configuration the seat name can be used by\n clients to help identify which physical devices the seat\n represents.\n\n The seat name is a UTF-8 string with no convention defined for\n its contents. Each name is unique among all wl_seat globals. The\n name is only guaranteed to be unique for the current compositor\n instance.\n\n The same seat names are used for all clients. Thus, the name can\n be shared across processes to refer to a specific wl_seat\n global.\n\n The name event is sent after binding to the seat global. This\n event is only sent once per seat object, and the name does not\n change over the lifetime of the wl_seat global.\n\n Compositors may re-use the same seat name if the wl_seat global\n is destroyed and re-created later.\n @param name seat identifier\n @since 2"]
     pub name: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_seat: *mut wl_seat,
             name: *const ::std::os::raw::c_char,
         ),
     >,
 }
 #[test]
 fn bindgen_test_layout_wl_seat_listener() {
     const UNINIT: ::std::mem::MaybeUninit<wl_seat_listener> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_seat_listener>(),
         16usize,
         concat!("Size of: ", stringify!(wl_seat_listener))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_seat_listener>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_seat_listener))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).capabilities) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_seat_listener),
             "::",
             stringify!(capabilities)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_seat_listener),
             "::",
             stringify!(name)
         )
     );
 }
 #[doc = " given wl_surface has another role"]
 pub const wl_pointer_error_WL_POINTER_ERROR_ROLE: wl_pointer_error = 0;
 pub type wl_pointer_error = ::std::os::raw::c_uint;
 #[doc = " the button is not pressed"]
 pub const wl_pointer_button_state_WL_POINTER_BUTTON_STATE_RELEASED: wl_pointer_button_state = 0;
 #[doc = " the button is pressed"]
 pub const wl_pointer_button_state_WL_POINTER_BUTTON_STATE_PRESSED: wl_pointer_button_state = 1;
 #[doc = " @ingroup iface_wl_pointer\n physical button state\n\n Describes the physical state of a button that produced the button\n event."]
 pub type wl_pointer_button_state = ::std::os::raw::c_uint;
 #[doc = " vertical axis"]
 pub const wl_pointer_axis_WL_POINTER_AXIS_VERTICAL_SCROLL: wl_pointer_axis = 0;
 #[doc = " horizontal axis"]
 pub const wl_pointer_axis_WL_POINTER_AXIS_HORIZONTAL_SCROLL: wl_pointer_axis = 1;
 #[doc = " @ingroup iface_wl_pointer\n axis types\n\n Describes the axis types of scroll events."]
 pub type wl_pointer_axis = ::std::os::raw::c_uint;
 #[doc = " a physical wheel rotation"]
 pub const wl_pointer_axis_source_WL_POINTER_AXIS_SOURCE_WHEEL: wl_pointer_axis_source = 0;
 #[doc = " finger on a touch surface"]
 pub const wl_pointer_axis_source_WL_POINTER_AXIS_SOURCE_FINGER: wl_pointer_axis_source = 1;
 #[doc = " continuous coordinate space"]
 pub const wl_pointer_axis_source_WL_POINTER_AXIS_SOURCE_CONTINUOUS: wl_pointer_axis_source = 2;
 #[doc = " a physical wheel tilt\n @since 6"]
 pub const wl_pointer_axis_source_WL_POINTER_AXIS_SOURCE_WHEEL_TILT: wl_pointer_axis_source = 3;
 #[doc = " @ingroup iface_wl_pointer\n axis source types\n\n Describes the source types for axis events. This indicates to the\n client how an axis event was physically generated; a client may\n adjust the user interface accordingly. For example, scroll events\n from a \"finger\" source may be in a smooth coordinate space with\n kinetic scrolling whereas a \"wheel\" source may be in discrete steps\n of a number of lines.\n\n The \"continuous\" axis source is a device generating events in a\n continuous coordinate space, but using something other than a\n finger. One example for this source is button-based scrolling where\n the vertical motion of a device is converted to scroll events while\n a button is held down.\n\n The \"wheel tilt\" axis source indicates that the actual device is a\n wheel but the scroll event is not caused by a rotation but a\n (usually sideways) tilt of the wheel."]
 pub type wl_pointer_axis_source = ::std::os::raw::c_uint;
 #[doc = " physical motion matches axis direction"]
 pub const wl_pointer_axis_relative_direction_WL_POINTER_AXIS_RELATIVE_DIRECTION_IDENTICAL:
     wl_pointer_axis_relative_direction = 0;
 #[doc = " physical motion is the inverse of the axis direction"]
 pub const wl_pointer_axis_relative_direction_WL_POINTER_AXIS_RELATIVE_DIRECTION_INVERTED:
     wl_pointer_axis_relative_direction = 1;
 #[doc = " @ingroup iface_wl_pointer\n axis relative direction\n\n This specifies the direction of the physical motion that caused a\n wl_pointer.axis event, relative to the wl_pointer.axis direction."]
 pub type wl_pointer_axis_relative_direction = ::std::os::raw::c_uint;
 #[doc = " @ingroup iface_wl_pointer\n @struct wl_pointer_listener"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_pointer_listener {
     #[doc = " enter event\n\n Notification that this seat's pointer is focused on a certain\n surface.\n\n When a seat's focus enters a surface, the pointer image is\n undefined and a client should respond to this event by setting\n an appropriate pointer image with the set_cursor request.\n @param serial serial number of the enter event\n @param surface surface entered by the pointer\n @param surface_x surface-local x coordinate\n @param surface_y surface-local y coordinate"]
     pub enter: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_pointer: *mut wl_pointer,
             serial: u32,
             surface: *mut wl_surface,
             surface_x: wl_fixed_t,
             surface_y: wl_fixed_t,
         ),
     >,
     #[doc = " leave event\n\n Notification that this seat's pointer is no longer focused on\n a certain surface.\n\n The leave notification is sent before the enter notification for\n the new focus.\n @param serial serial number of the leave event\n @param surface surface left by the pointer"]
     pub leave: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_pointer: *mut wl_pointer,
             serial: u32,
             surface: *mut wl_surface,
         ),
     >,
     #[doc = " pointer motion event\n\n Notification of pointer location change. The arguments\n surface_x and surface_y are the location relative to the focused\n surface.\n @param time timestamp with millisecond granularity\n @param surface_x surface-local x coordinate\n @param surface_y surface-local y coordinate"]
     pub motion: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_pointer: *mut wl_pointer,
             time: u32,
             surface_x: wl_fixed_t,
             surface_y: wl_fixed_t,
         ),
     >,
     #[doc = " pointer button event\n\n Mouse button click and release notifications.\n\n The location of the click is given by the last motion or enter\n event. The time argument is a timestamp with millisecond\n granularity, with an undefined base.\n\n The button is a button code as defined in the Linux kernel's\n linux/input-event-codes.h header file, e.g. BTN_LEFT.\n\n Any 16-bit button code value is reserved for future additions to\n the kernel's event code list. All other button codes above\n 0xFFFF are currently undefined but may be used in future\n versions of this protocol.\n @param serial serial number of the button event\n @param time timestamp with millisecond granularity\n @param button button that produced the event\n @param state physical state of the button"]
     pub button: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_pointer: *mut wl_pointer,
             serial: u32,
             time: u32,
             button: u32,
             state: u32,
         ),
     >,
     #[doc = " axis event\n\n Scroll and other axis notifications.\n\n For scroll events (vertical and horizontal scroll axes), the\n value parameter is the length of a vector along the specified\n axis in a coordinate space identical to those of motion events,\n representing a relative movement along the specified axis.\n\n For devices that support movements non-parallel to axes multiple\n axis events will be emitted.\n\n When applicable, for example for touch pads, the server can\n choose to emit scroll events where the motion vector is\n equivalent to a motion event vector.\n\n When applicable, a client can transform its content relative to\n the scroll distance.\n @param time timestamp with millisecond granularity\n @param axis axis type\n @param value length of vector in surface-local coordinate space"]
     pub axis: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_pointer: *mut wl_pointer,
             time: u32,
             axis: u32,
             value: wl_fixed_t,
         ),
     >,
     #[doc = " end of a pointer event sequence\n\n Indicates the end of a set of events that logically belong\n together. A client is expected to accumulate the data in all\n events within the frame before proceeding.\n\n All wl_pointer events before a wl_pointer.frame event belong\n logically together. For example, in a diagonal scroll motion the\n compositor will send an optional wl_pointer.axis_source event,\n two wl_pointer.axis events (horizontal and vertical) and finally\n a wl_pointer.frame event. The client may use this information to\n calculate a diagonal vector for scrolling.\n\n When multiple wl_pointer.axis events occur within the same\n frame, the motion vector is the combined motion of all events.\n When a wl_pointer.axis and a wl_pointer.axis_stop event occur\n within the same frame, this indicates that axis movement in one\n axis has stopped but continues in the other axis. When multiple\n wl_pointer.axis_stop events occur within the same frame, this\n indicates that these axes stopped in the same instance.\n\n A wl_pointer.frame event is sent for every logical event group,\n even if the group only contains a single wl_pointer event.\n Specifically, a client may get a sequence: motion, frame,\n button, frame, axis, frame, axis_stop, frame.\n\n The wl_pointer.enter and wl_pointer.leave events are logical\n events generated by the compositor and not the hardware. These\n events are also grouped by a wl_pointer.frame. When a pointer\n moves from one surface to another, a compositor should group the\n wl_pointer.leave event within the same wl_pointer.frame.\n However, a client must not rely on wl_pointer.leave and\n wl_pointer.enter being in the same wl_pointer.frame.\n Compositor-specific policies may require the wl_pointer.leave\n and wl_pointer.enter event being split across multiple\n wl_pointer.frame groups.\n @since 5"]
     pub frame: ::std::option::Option<
         unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, wl_pointer: *mut wl_pointer),
     >,
     #[doc = " axis source event\n\n Source information for scroll and other axes.\n\n This event does not occur on its own. It is sent before a\n wl_pointer.frame event and carries the source information for\n all events within that frame.\n\n The source specifies how this event was generated. If the source\n is wl_pointer.axis_source.finger, a wl_pointer.axis_stop event\n will be sent when the user lifts the finger off the device.\n\n If the source is wl_pointer.axis_source.wheel,\n wl_pointer.axis_source.wheel_tilt or\n wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event\n may or may not be sent. Whether a compositor sends an axis_stop\n event for these sources is hardware-specific and\n implementation-dependent; clients must not rely on receiving an\n axis_stop event for these scroll sources and should treat scroll\n sequences from these scroll sources as unterminated by default.\n\n This event is optional. If the source is unknown for a\n particular axis event sequence, no event is sent. Only one\n wl_pointer.axis_source event is permitted per frame.\n\n The order of wl_pointer.axis_discrete and wl_pointer.axis_source\n is not guaranteed.\n @param axis_source source of the axis event\n @since 5"]
     pub axis_source: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_pointer: *mut wl_pointer,
             axis_source: u32,
         ),
     >,
     #[doc = " axis stop event\n\n Stop notification for scroll and other axes.\n\n For some wl_pointer.axis_source types, a wl_pointer.axis_stop\n event is sent to notify a client that the axis sequence has\n terminated. This enables the client to implement kinetic\n scrolling. See the wl_pointer.axis_source documentation for\n information on when this event may be generated.\n\n Any wl_pointer.axis events with the same axis_source after this\n event should be considered as the start of a new axis motion.\n\n The timestamp is to be interpreted identical to the timestamp in\n the wl_pointer.axis event. The timestamp value may be the same\n as a preceding wl_pointer.axis event.\n @param time timestamp with millisecond granularity\n @param axis the axis stopped with this event\n @since 5"]
     pub axis_stop: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_pointer: *mut wl_pointer,
             time: u32,
             axis: u32,
         ),
     >,
     #[doc = " axis click event\n\n Discrete step information for scroll and other axes.\n\n This event carries the axis value of the wl_pointer.axis event\n in discrete steps (e.g. mouse wheel clicks).\n\n This event is deprecated with wl_pointer version 8 - this event\n is not sent to clients supporting version 8 or later.\n\n This event does not occur on its own, it is coupled with a\n wl_pointer.axis event that represents this axis value on a\n continuous scale. The protocol guarantees that each\n axis_discrete event is always followed by exactly one axis event\n with the same axis number within the same wl_pointer.frame. Note\n that the protocol allows for other events to occur between the\n axis_discrete and its coupled axis event, including other\n axis_discrete or axis events. A wl_pointer.frame must not\n contain more than one axis_discrete event per axis type.\n\n This event is optional; continuous scrolling devices like\n two-finger scrolling on touchpads do not have discrete steps and\n do not generate this event.\n\n The discrete value carries the directional information. e.g. a\n value of -2 is two steps towards the negative direction of this\n axis.\n\n The axis number is identical to the axis number in the\n associated axis event.\n\n The order of wl_pointer.axis_discrete and wl_pointer.axis_source\n is not guaranteed.\n @param axis axis type\n @param discrete number of steps\n @since 5"]
     pub axis_discrete: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_pointer: *mut wl_pointer,
             axis: u32,
             discrete: i32,
         ),
     >,
     #[doc = " axis high-resolution scroll event\n\n Discrete high-resolution scroll information.\n\n This event carries high-resolution wheel scroll information,\n with each multiple of 120 representing one logical scroll step\n (a wheel detent). For example, an axis_value120 of 30 is one\n quarter of a logical scroll step in the positive direction, a\n value120 of -240 are two logical scroll steps in the negative\n direction within the same hardware event. Clients that rely on\n discrete scrolling should accumulate the value120 to multiples\n of 120 before processing the event.\n\n The value120 must not be zero.\n\n This event replaces the wl_pointer.axis_discrete event in\n clients supporting wl_pointer version 8 or later.\n\n Where a wl_pointer.axis_source event occurs in the same\n wl_pointer.frame, the axis source applies to this event.\n\n The order of wl_pointer.axis_value120 and wl_pointer.axis_source\n is not guaranteed.\n @param axis axis type\n @param value120 scroll distance as fraction of 120\n @since 8"]
     pub axis_value120: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_pointer: *mut wl_pointer,
             axis: u32,
             value120: i32,
         ),
     >,
     #[doc = " axis relative physical direction event\n\n Relative directional information of the entity causing the\n axis motion.\n\n For a wl_pointer.axis event, the\n wl_pointer.axis_relative_direction event specifies the movement\n direction of the entity causing the wl_pointer.axis event. For\n example: - if a user's fingers on a touchpad move down and this\n causes a wl_pointer.axis vertical_scroll down event, the\n physical direction is 'identical' - if a user's fingers on a\n touchpad move down and this causes a wl_pointer.axis\n vertical_scroll up scroll up event ('natural scrolling'), the\n physical direction is 'inverted'.\n\n A client may use this information to adjust scroll motion of\n components. Specifically, enabling natural scrolling causes the\n content to change direction compared to traditional scrolling.\n Some widgets like volume control sliders should usually match\n the physical direction regardless of whether natural scrolling\n is active. This event enables clients to match the scroll\n direction of a widget to the physical direction.\n\n This event does not occur on its own, it is coupled with a\n wl_pointer.axis event that represents this axis value. The\n protocol guarantees that each axis_relative_direction event is\n always followed by exactly one axis event with the same axis\n number within the same wl_pointer.frame. Note that the protocol\n allows for other events to occur between the\n axis_relative_direction and its coupled axis event.\n\n The axis number is identical to the axis number in the\n associated axis event.\n\n The order of wl_pointer.axis_relative_direction,\n wl_pointer.axis_discrete and wl_pointer.axis_source is not\n guaranteed.\n @param axis axis type\n @param direction physical direction relative to axis motion\n @since 9"]
     pub axis_relative_direction: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_pointer: *mut wl_pointer,
             axis: u32,
             direction: u32,
         ),
     >,
 }
 #[test]
 fn bindgen_test_layout_wl_pointer_listener() {
     const UNINIT: ::std::mem::MaybeUninit<wl_pointer_listener> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_pointer_listener>(),
         88usize,
         concat!("Size of: ", stringify!(wl_pointer_listener))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_pointer_listener>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_pointer_listener))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).enter) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_pointer_listener),
             "::",
             stringify!(enter)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).leave) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_pointer_listener),
             "::",
             stringify!(leave)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).motion) as usize - ptr as usize },
         16usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_pointer_listener),
             "::",
             stringify!(motion)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
         24usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_pointer_listener),
             "::",
             stringify!(button)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).axis) as usize - ptr as usize },
         32usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_pointer_listener),
             "::",
             stringify!(axis)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
         40usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_pointer_listener),
             "::",
             stringify!(frame)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).axis_source) as usize - ptr as usize },
         48usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_pointer_listener),
             "::",
             stringify!(axis_source)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).axis_stop) as usize - ptr as usize },
         56usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_pointer_listener),
             "::",
             stringify!(axis_stop)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).axis_discrete) as usize - ptr as usize },
         64usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_pointer_listener),
             "::",
             stringify!(axis_discrete)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).axis_value120) as usize - ptr as usize },
         72usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_pointer_listener),
             "::",
             stringify!(axis_value120)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).axis_relative_direction) as usize - ptr as usize },
         80usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_pointer_listener),
             "::",
             stringify!(axis_relative_direction)
         )
     );
 }
 #[doc = " no keymap; client must understand how to interpret the raw keycode"]
 pub const wl_keyboard_keymap_format_WL_KEYBOARD_KEYMAP_FORMAT_NO_KEYMAP: wl_keyboard_keymap_format =
     0;
 #[doc = " libxkbcommon compatible, null-terminated string; to determine the xkb keycode, clients must add 8 to the key event keycode"]
 pub const wl_keyboard_keymap_format_WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1: wl_keyboard_keymap_format = 1;
 #[doc = " @ingroup iface_wl_keyboard\n keyboard mapping format\n\n This specifies the format of the keymap provided to the\n client with the wl_keyboard.keymap event."]
 pub type wl_keyboard_keymap_format = ::std::os::raw::c_uint;
 #[doc = " key is not pressed"]
 pub const wl_keyboard_key_state_WL_KEYBOARD_KEY_STATE_RELEASED: wl_keyboard_key_state = 0;
 #[doc = " key is pressed"]
 pub const wl_keyboard_key_state_WL_KEYBOARD_KEY_STATE_PRESSED: wl_keyboard_key_state = 1;
 #[doc = " @ingroup iface_wl_keyboard\n physical key state\n\n Describes the physical state of a key that produced the key event."]
 pub type wl_keyboard_key_state = ::std::os::raw::c_uint;
 #[doc = " @ingroup iface_wl_keyboard\n @struct wl_keyboard_listener"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_keyboard_listener {
     #[doc = " keyboard mapping\n\n This event provides a file descriptor to the client which can\n be memory-mapped in read-only mode to provide a keyboard mapping\n description.\n\n From version 7 onwards, the fd must be mapped with MAP_PRIVATE\n by the recipient, as MAP_SHARED may fail.\n @param format keymap format\n @param fd keymap file descriptor\n @param size keymap size, in bytes"]
     pub keymap: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_keyboard: *mut wl_keyboard,
             format: u32,
             fd: i32,
             size: u32,
         ),
     >,
     #[doc = " enter event\n\n Notification that this seat's keyboard focus is on a certain\n surface.\n\n The compositor must send the wl_keyboard.modifiers event after\n this event.\n @param serial serial number of the enter event\n @param surface surface gaining keyboard focus\n @param keys the currently pressed keys"]
     pub enter: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_keyboard: *mut wl_keyboard,
             serial: u32,
             surface: *mut wl_surface,
             keys: *mut wl_array,
         ),
     >,
     #[doc = " leave event\n\n Notification that this seat's keyboard focus is no longer on a\n certain surface.\n\n The leave notification is sent before the enter notification for\n the new focus.\n\n After this event client must assume that all keys, including\n modifiers, are lifted and also it must stop key repeating if\n there's some going on.\n @param serial serial number of the leave event\n @param surface surface that lost keyboard focus"]
     pub leave: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_keyboard: *mut wl_keyboard,
             serial: u32,
             surface: *mut wl_surface,
         ),
     >,
     #[doc = " key event\n\n A key was pressed or released. The time argument is a\n timestamp with millisecond granularity, with an undefined base.\n\n The key is a platform-specific key code that can be interpreted\n by feeding it to the keyboard mapping (see the keymap event).\n\n If this event produces a change in modifiers, then the resulting\n wl_keyboard.modifiers event must be sent after this event.\n @param serial serial number of the key event\n @param time timestamp with millisecond granularity\n @param key key that produced the event\n @param state physical state of the key"]
     pub key: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_keyboard: *mut wl_keyboard,
             serial: u32,
             time: u32,
             key: u32,
             state: u32,
         ),
     >,
     #[doc = " modifier and group state\n\n Notifies clients that the modifier and/or group state has\n changed, and it should update its local state.\n @param serial serial number of the modifiers event\n @param mods_depressed depressed modifiers\n @param mods_latched latched modifiers\n @param mods_locked locked modifiers\n @param group keyboard layout"]
     pub modifiers: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_keyboard: *mut wl_keyboard,
             serial: u32,
             mods_depressed: u32,
             mods_latched: u32,
             mods_locked: u32,
             group: u32,
         ),
     >,
     #[doc = " repeat rate and delay\n\n Informs the client about the keyboard's repeat rate and delay.\n\n This event is sent as soon as the wl_keyboard object has been\n created, and is guaranteed to be received by the client before\n any key press event.\n\n Negative values for either rate or delay are illegal. A rate of\n zero will disable any repeating (regardless of the value of\n delay).\n\n This event can be sent later on as well with a new value if\n necessary, so clients should continue listening for the event\n past the creation of wl_keyboard.\n @param rate the rate of repeating keys in characters per second\n @param delay delay in milliseconds since key down until repeating starts\n @since 4"]
     pub repeat_info: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_keyboard: *mut wl_keyboard,
             rate: i32,
             delay: i32,
         ),
     >,
 }
 #[test]
 fn bindgen_test_layout_wl_keyboard_listener() {
     const UNINIT: ::std::mem::MaybeUninit<wl_keyboard_listener> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_keyboard_listener>(),
         48usize,
         concat!("Size of: ", stringify!(wl_keyboard_listener))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_keyboard_listener>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_keyboard_listener))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).keymap) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_keyboard_listener),
             "::",
             stringify!(keymap)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).enter) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_keyboard_listener),
             "::",
             stringify!(enter)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).leave) as usize - ptr as usize },
         16usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_keyboard_listener),
             "::",
             stringify!(leave)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
         24usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_keyboard_listener),
             "::",
             stringify!(key)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).modifiers) as usize - ptr as usize },
         32usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_keyboard_listener),
             "::",
             stringify!(modifiers)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).repeat_info) as usize - ptr as usize },
         40usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_keyboard_listener),
             "::",
             stringify!(repeat_info)
         )
     );
 }
 #[doc = " @ingroup iface_wl_touch\n @struct wl_touch_listener"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_touch_listener {
     #[doc = " touch down event and beginning of a touch sequence\n\n A new touch point has appeared on the surface. This touch\n point is assigned a unique ID. Future events from this touch\n point reference this ID. The ID ceases to be valid after a touch\n up event and may be reused in the future.\n @param serial serial number of the touch down event\n @param time timestamp with millisecond granularity\n @param surface surface touched\n @param id the unique ID of this touch point\n @param x surface-local x coordinate\n @param y surface-local y coordinate"]
     pub down: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_touch: *mut wl_touch,
             serial: u32,
             time: u32,
             surface: *mut wl_surface,
             id: i32,
             x: wl_fixed_t,
             y: wl_fixed_t,
         ),
     >,
     #[doc = " end of a touch event sequence\n\n The touch point has disappeared. No further events will be\n sent for this touch point and the touch point's ID is released\n and may be reused in a future touch down event.\n @param serial serial number of the touch up event\n @param time timestamp with millisecond granularity\n @param id the unique ID of this touch point"]
     pub up: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_touch: *mut wl_touch,
             serial: u32,
             time: u32,
             id: i32,
         ),
     >,
     #[doc = " update of touch point coordinates\n\n A touch point has changed coordinates.\n @param time timestamp with millisecond granularity\n @param id the unique ID of this touch point\n @param x surface-local x coordinate\n @param y surface-local y coordinate"]
     pub motion: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_touch: *mut wl_touch,
             time: u32,
             id: i32,
             x: wl_fixed_t,
             y: wl_fixed_t,
         ),
     >,
     #[doc = " end of touch frame event\n\n Indicates the end of a set of events that logically belong\n together. A client is expected to accumulate the data in all\n events within the frame before proceeding.\n\n A wl_touch.frame terminates at least one event but otherwise no\n guarantee is provided about the set of events within a frame. A\n client must assume that any state not updated in a frame is\n unchanged from the previously known state."]
     pub frame: ::std::option::Option<
         unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, wl_touch: *mut wl_touch),
     >,
     #[doc = " touch session cancelled\n\n Sent if the compositor decides the touch stream is a global\n gesture. No further events are sent to the clients from that\n particular gesture. Touch cancellation applies to all touch\n points currently active on this client's surface. The client is\n responsible for finalizing the touch points, future touch points\n on this surface may reuse the touch point ID."]
     pub cancel: ::std::option::Option<
         unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, wl_touch: *mut wl_touch),
     >,
     #[doc = " update shape of touch point\n\n Sent when a touchpoint has changed its shape.\n\n This event does not occur on its own. It is sent before a\n wl_touch.frame event and carries the new shape information for\n any previously reported, or new touch points of that frame.\n\n Other events describing the touch point such as wl_touch.down,\n wl_touch.motion or wl_touch.orientation may be sent within the\n same wl_touch.frame. A client should treat these events as a\n single logical touch point update. The order of wl_touch.shape,\n wl_touch.orientation and wl_touch.motion is not guaranteed. A\n wl_touch.down event is guaranteed to occur before the first\n wl_touch.shape event for this touch ID but both events may occur\n within the same wl_touch.frame.\n\n A touchpoint shape is approximated by an ellipse through the\n major and minor axis length. The major axis length describes the\n longer diameter of the ellipse, while the minor axis length\n describes the shorter diameter. Major and minor are orthogonal\n and both are specified in surface-local coordinates. The center\n of the ellipse is always at the touchpoint location as reported\n by wl_touch.down or wl_touch.move.\n\n This event is only sent by the compositor if the touch device\n supports shape reports. The client has to make reasonable\n assumptions about the shape if it did not receive this event.\n @param id the unique ID of this touch point\n @param major length of the major axis in surface-local coordinates\n @param minor length of the minor axis in surface-local coordinates\n @since 6"]
     pub shape: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_touch: *mut wl_touch,
             id: i32,
             major: wl_fixed_t,
             minor: wl_fixed_t,
         ),
     >,
     #[doc = " update orientation of touch point\n\n Sent when a touchpoint has changed its orientation.\n\n This event does not occur on its own. It is sent before a\n wl_touch.frame event and carries the new shape information for\n any previously reported, or new touch points of that frame.\n\n Other events describing the touch point such as wl_touch.down,\n wl_touch.motion or wl_touch.shape may be sent within the same\n wl_touch.frame. A client should treat these events as a single\n logical touch point update. The order of wl_touch.shape,\n wl_touch.orientation and wl_touch.motion is not guaranteed. A\n wl_touch.down event is guaranteed to occur before the first\n wl_touch.orientation event for this touch ID but both events may\n occur within the same wl_touch.frame.\n\n The orientation describes the clockwise angle of a touchpoint's\n major axis to the positive surface y-axis and is normalized to\n the -180 to +180 degree range. The granularity of orientation\n depends on the touch device, some devices only support binary\n rotation values between 0 and 90 degrees.\n\n This event is only sent by the compositor if the touch device\n supports orientation reports.\n @param id the unique ID of this touch point\n @param orientation angle between major axis and positive surface y-axis in degrees\n @since 6"]
     pub orientation: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_touch: *mut wl_touch,
             id: i32,
             orientation: wl_fixed_t,
         ),
     >,
 }
 #[test]
 fn bindgen_test_layout_wl_touch_listener() {
     const UNINIT: ::std::mem::MaybeUninit<wl_touch_listener> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_touch_listener>(),
         56usize,
         concat!("Size of: ", stringify!(wl_touch_listener))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_touch_listener>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_touch_listener))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).down) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_touch_listener),
             "::",
             stringify!(down)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).up) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_touch_listener),
             "::",
             stringify!(up)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).motion) as usize - ptr as usize },
         16usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_touch_listener),
             "::",
             stringify!(motion)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
         24usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_touch_listener),
             "::",
             stringify!(frame)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
         32usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_touch_listener),
             "::",
             stringify!(cancel)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).shape) as usize - ptr as usize },
         40usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_touch_listener),
             "::",
             stringify!(shape)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).orientation) as usize - ptr as usize },
         48usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_touch_listener),
             "::",
             stringify!(orientation)
         )
     );
 }
 #[doc = " unknown geometry"]
 pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_UNKNOWN: wl_output_subpixel = 0;
 #[doc = " no geometry"]
 pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_NONE: wl_output_subpixel = 1;
 #[doc = " horizontal RGB"]
 pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB: wl_output_subpixel = 2;
 #[doc = " horizontal BGR"]
 pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR: wl_output_subpixel = 3;
 #[doc = " vertical RGB"]
 pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_VERTICAL_RGB: wl_output_subpixel = 4;
 #[doc = " vertical BGR"]
 pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_VERTICAL_BGR: wl_output_subpixel = 5;
 #[doc = " @ingroup iface_wl_output\n subpixel geometry information\n\n This enumeration describes how the physical\n pixels on an output are laid out."]
 pub type wl_output_subpixel = ::std::os::raw::c_uint;
 #[doc = " no transform"]
 pub const wl_output_transform_WL_OUTPUT_TRANSFORM_NORMAL: wl_output_transform = 0;
 #[doc = " 90 degrees counter-clockwise"]
 pub const wl_output_transform_WL_OUTPUT_TRANSFORM_90: wl_output_transform = 1;
 #[doc = " 180 degrees counter-clockwise"]
 pub const wl_output_transform_WL_OUTPUT_TRANSFORM_180: wl_output_transform = 2;
 #[doc = " 270 degrees counter-clockwise"]
 pub const wl_output_transform_WL_OUTPUT_TRANSFORM_270: wl_output_transform = 3;
 #[doc = " 180 degree flip around a vertical axis"]
 pub const wl_output_transform_WL_OUTPUT_TRANSFORM_FLIPPED: wl_output_transform = 4;
 #[doc = " flip and rotate 90 degrees counter-clockwise"]
 pub const wl_output_transform_WL_OUTPUT_TRANSFORM_FLIPPED_90: wl_output_transform = 5;
 #[doc = " flip and rotate 180 degrees counter-clockwise"]
 pub const wl_output_transform_WL_OUTPUT_TRANSFORM_FLIPPED_180: wl_output_transform = 6;
 #[doc = " flip and rotate 270 degrees counter-clockwise"]
 pub const wl_output_transform_WL_OUTPUT_TRANSFORM_FLIPPED_270: wl_output_transform = 7;
 #[doc = " @ingroup iface_wl_output\n transform from framebuffer to output\n\n This describes the transform that a compositor will apply to a\n surface to compensate for the rotation or mirroring of an\n output device.\n\n The flipped values correspond to an initial flip around a\n vertical axis followed by rotation.\n\n The purpose is mainly to allow clients to render accordingly and\n tell the compositor, so that for fullscreen surfaces, the\n compositor will still be able to scan out directly from client\n surfaces."]
 pub type wl_output_transform = ::std::os::raw::c_uint;
 #[doc = " indicates this is the current mode"]
 pub const wl_output_mode_WL_OUTPUT_MODE_CURRENT: wl_output_mode = 1;
 #[doc = " indicates this is the preferred mode"]
 pub const wl_output_mode_WL_OUTPUT_MODE_PREFERRED: wl_output_mode = 2;
 #[doc = " @ingroup iface_wl_output\n mode information\n\n These flags describe properties of an output mode.\n They are used in the flags bitfield of the mode event."]
 pub type wl_output_mode = ::std::os::raw::c_uint;
 #[doc = " @ingroup iface_wl_output\n @struct wl_output_listener"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct wl_output_listener {
     #[doc = " properties of the output\n\n The geometry event describes geometric properties of the\n output. The event is sent when binding to the output object and\n whenever any of the properties change.\n\n The physical size can be set to zero if it doesn't make sense\n for this output (e.g. for projectors or virtual outputs).\n\n The geometry event will be followed by a done event (starting\n from version 2).\n\n Note: wl_output only advertises partial information about the\n output position and identification. Some compositors, for\n instance those not implementing a desktop-style output layout or\n those exposing virtual outputs, might fake this information.\n Instead of using x and y, clients should use\n xdg_output.logical_position. Instead of using make and model,\n clients should use name and description.\n @param x x position within the global compositor space\n @param y y position within the global compositor space\n @param physical_width width in millimeters of the output\n @param physical_height height in millimeters of the output\n @param subpixel subpixel orientation of the output\n @param make textual description of the manufacturer\n @param model textual description of the model\n @param transform transform that maps framebuffer to output"]
     pub geometry: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_output: *mut wl_output,
             x: i32,
             y: i32,
             physical_width: i32,
             physical_height: i32,
             subpixel: i32,
             make: *const ::std::os::raw::c_char,
             model: *const ::std::os::raw::c_char,
             transform: i32,
         ),
     >,
     #[doc = " advertise available modes for the output\n\n The mode event describes an available mode for the output.\n\n The event is sent when binding to the output object and there\n will always be one mode, the current mode. The event is sent\n again if an output changes mode, for the mode that is now\n current. In other words, the current mode is always the last\n mode that was received with the current flag set.\n\n Non-current modes are deprecated. A compositor can decide to\n only advertise the current mode and never send other modes.\n Clients should not rely on non-current modes.\n\n The size of a mode is given in physical hardware units of the\n output device. This is not necessarily the same as the output\n size in the global compositor space. For instance, the output\n may be scaled, as described in wl_output.scale, or transformed,\n as described in wl_output.transform. Clients willing to retrieve\n the output size in the global compositor space should use\n xdg_output.logical_size instead.\n\n The vertical refresh rate can be set to zero if it doesn't make\n sense for this output (e.g. for virtual outputs).\n\n The mode event will be followed by a done event (starting from\n version 2).\n\n Clients should not use the refresh rate to schedule frames.\n Instead, they should use the wl_surface.frame event or the\n presentation-time protocol.\n\n Note: this information is not always meaningful for all outputs.\n Some compositors, such as those exposing virtual outputs, might\n fake the refresh rate or the size.\n @param flags bitfield of mode flags\n @param width width of the mode in hardware units\n @param height height of the mode in hardware units\n @param refresh vertical refresh rate in mHz"]
     pub mode: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_output: *mut wl_output,
             flags: u32,
             width: i32,
             height: i32,
             refresh: i32,
         ),
     >,
     #[doc = " sent all information about output\n\n This event is sent after all other properties have been sent\n after binding to the output object and after any other property\n changes done after that. This allows changes to the output\n properties to be seen as atomic, even if they happen via\n multiple events.\n @since 2"]
     pub done: ::std::option::Option<
         unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, wl_output: *mut wl_output),
     >,
     #[doc = " output scaling properties\n\n This event contains scaling geometry information that is not\n in the geometry event. It may be sent after binding the output\n object or if the output scale changes later. If it is not sent,\n the client should assume a scale of 1.\n\n A scale larger than 1 means that the compositor will\n automatically scale surface buffers by this amount when\n rendering. This is used for very high resolution displays where\n applications rendering at the native resolution would be too\n small to be legible.\n\n It is intended that scaling aware clients track the current\n output of a surface, and if it is on a scaled output it should\n use wl_surface.set_buffer_scale with the scale of the output.\n That way the compositor can avoid scaling the surface, and the\n client can supply a higher detail image.\n\n The scale event will be followed by a done event.\n @param factor scaling factor of output\n @since 2"]
     pub scale: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_output: *mut wl_output,
             factor: i32,
         ),
     >,
     #[doc = " name of this output\n\n Many compositors will assign user-friendly names to their\n outputs, show them to the user, allow the user to refer to an\n output, etc. The client may wish to know this name as well to\n offer the user similar behaviors.\n\n The name is a UTF-8 string with no convention defined for its\n contents. Each name is unique among all wl_output globals. The\n name is only guaranteed to be unique for the compositor\n instance.\n\n The same output name is used for all clients for a given\n wl_output global. Thus, the name can be shared across processes\n to refer to a specific wl_output global.\n\n The name is not guaranteed to be persistent across sessions,\n thus cannot be used to reliably identify an output in e.g.\n configuration files.\n\n Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc.\n However, do not assume that the name is a reflection of an\n underlying DRM connector, X11 connection, etc.\n\n The name event is sent after binding the output object. This\n event is only sent once per output object, and the name does not\n change over the lifetime of the wl_output global.\n\n Compositors may re-use the same output name if the wl_output\n global is destroyed and re-created later. Compositors should\n avoid re-using the same name if possible.\n\n The name event will be followed by a done event.\n @param name output name\n @since 4"]
     pub name: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_output: *mut wl_output,
             name: *const ::std::os::raw::c_char,
         ),
     >,
     #[doc = " human-readable description of this output\n\n Many compositors can produce human-readable descriptions of\n their outputs. The client may wish to know this description as\n well, e.g. for output selection purposes.\n\n The description is a UTF-8 string with no convention defined for\n its contents. The description is not guaranteed to be unique\n among all wl_output globals. Examples might include 'Foocorp 11\"\n Display' or 'Virtual X11 output via :1'.\n\n The description event is sent after binding the output object\n and whenever the description changes. The description is\n optional, and may not be sent at all.\n\n The description event will be followed by a done event.\n @param description output description\n @since 4"]
     pub description: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             wl_output: *mut wl_output,
             description: *const ::std::os::raw::c_char,
         ),
     >,
 }
 #[test]
 fn bindgen_test_layout_wl_output_listener() {
     const UNINIT: ::std::mem::MaybeUninit<wl_output_listener> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<wl_output_listener>(),
         48usize,
         concat!("Size of: ", stringify!(wl_output_listener))
     );
     assert_eq!(
         ::std::mem::align_of::<wl_output_listener>(),
         8usize,
         concat!("Alignment of ", stringify!(wl_output_listener))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).geometry) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_output_listener),
             "::",
             stringify!(geometry)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_output_listener),
             "::",
             stringify!(mode)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).done) as usize - ptr as usize },
         16usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_output_listener),
             "::",
             stringify!(done)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
         24usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_output_listener),
             "::",
             stringify!(scale)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
         32usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_output_listener),
             "::",
             stringify!(name)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
         40usize,
         concat!(
             "Offset of field: ",
             stringify!(wl_output_listener),
             "::",
             stringify!(description)
         )
     );
 }
 #[doc = " the to-be sub-surface is invalid"]
 pub const wl_subcompositor_error_WL_SUBCOMPOSITOR_ERROR_BAD_SURFACE: wl_subcompositor_error = 0;
 #[doc = " the to-be sub-surface parent is invalid"]
 pub const wl_subcompositor_error_WL_SUBCOMPOSITOR_ERROR_BAD_PARENT: wl_subcompositor_error = 1;
 pub type wl_subcompositor_error = ::std::os::raw::c_uint;
 #[doc = " wl_surface is not a sibling or the parent"]
 pub const wl_subsurface_error_WL_SUBSURFACE_ERROR_BAD_SURFACE: wl_subsurface_error = 0;
 pub type wl_subsurface_error = ::std::os::raw::c_uint;
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct xdg_popup {
     _unused: [u8; 0],
 }
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct xdg_positioner {
     _unused: [u8; 0],
 }
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdg_surface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdg_toplevel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdg_wm_base {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @page page_iface_xdg_wm_base xdg_wm_base\n @section page_iface_xdg_wm_base_desc Description\n\n The xdg_wm_base interface is exposed as a global object enabling clients\n to turn their wl_surfaces into windows in a desktop environment. It\n defines the basic functionality needed for clients and the compositor to\n create windows that can be dragged, resized, maximized, etc, as well as\n creating transient windows such as popup menus.\n @section page_iface_xdg_wm_base_api API\n See @ref iface_xdg_wm_base.\n/\n/**\n @defgroup iface_xdg_wm_base The xdg_wm_base interface\n\n The xdg_wm_base interface is exposed as a global object enabling clients\n to turn their wl_surfaces into windows in a desktop environment. It\n defines the basic functionality needed for clients and the compositor to\n create windows that can be dragged, resized, maximized, etc, as well as\n creating transient windows such as popup menus."]
    pub static xdg_wm_base_interface: wl_interface;
}
 extern "C" {
     #[doc = " @page page_iface_xdg_positioner xdg_positioner\n @section page_iface_xdg_positioner_desc Description\n\n The xdg_positioner provides a collection of rules for the placement of a\n child surface relative to a parent surface. Rules can be defined to ensure\n the child surface remains within the visible area's borders, and to\n specify how the child surface changes its position, such as sliding along\n an axis, or flipping around a rectangle. These positioner-created rules are\n constrained by the requirement that a child surface must intersect with or\n be at least partially adjacent to its parent surface.\n\n See the various requests for details about possible rules.\n\n At the time of the request, the compositor makes a copy of the rules\n specified by the xdg_positioner. Thus, after the request is complete the\n xdg_positioner object can be destroyed or reused; further changes to the\n object will have no effect on previous usages.\n\n For an xdg_positioner object to be considered complete, it must have a\n non-zero size set by set_size, and a non-zero anchor rectangle set by\n set_anchor_rect. Passing an incomplete xdg_positioner object when\n positioning a surface raises an invalid_positioner error.\n @section page_iface_xdg_positioner_api API\n See @ref iface_xdg_positioner.\n/\n/**\n @defgroup iface_xdg_positioner The xdg_positioner interface\n\n The xdg_positioner provides a collection of rules for the placement of a\n child surface relative to a parent surface. Rules can be defined to ensure\n the child surface remains within the visible area's borders, and to\n specify how the child surface changes its position, such as sliding along\n an axis, or flipping around a rectangle. These positioner-created rules are\n constrained by the requirement that a child surface must intersect with or\n be at least partially adjacent to its parent surface.\n\n See the various requests for details about possible rules.\n\n At the time of the request, the compositor makes a copy of the rules\n specified by the xdg_positioner. Thus, after the request is complete the\n xdg_positioner object can be destroyed or reused; further changes to the\n object will have no effect on previous usages.\n\n For an xdg_positioner object to be considered complete, it must have a\n non-zero size set by set_size, and a non-zero anchor rectangle set by\n set_anchor_rect. Passing an incomplete xdg_positioner object when\n positioning a surface raises an invalid_positioner error."]
     pub static xdg_positioner_interface: wl_interface;
 }
extern "C" {
    #[doc = " @page page_iface_xdg_surface xdg_surface\n @section page_iface_xdg_surface_desc Description\n\n An interface that may be implemented by a wl_surface, for\n implementations that provide a desktop-style user interface.\n\n It provides a base set of functionality required to construct user\n interface elements requiring management by the compositor, such as\n toplevel windows, menus, etc. The types of functionality are split into\n xdg_surface roles.\n\n Creating an xdg_surface does not set the role for a wl_surface. In order\n to map an xdg_surface, the client must create a role-specific object\n using, e.g., get_toplevel, get_popup. The wl_surface for any given\n xdg_surface can have at most one role, and may not be assigned any role\n not based on xdg_surface.\n\n A role must be assigned before any other requests are made to the\n xdg_surface object.\n\n The client must call wl_surface.commit on the corresponding wl_surface\n for the xdg_surface state to take effect.\n\n Creating an xdg_surface from a wl_surface which has a buffer attached or\n committed is a client error, and any attempts by a client to attach or\n manipulate a buffer prior to the first xdg_surface.configure call must\n also be treated as errors.\n\n After creating a role-specific object and setting it up, the client must\n perform an initial commit without any buffer attached. The compositor\n will reply with initial wl_surface state such as\n wl_surface.preferred_buffer_scale followed by an xdg_surface.configure\n event. The client must acknowledge it and is then allowed to attach a\n buffer to map the surface.\n\n Mapping an xdg_surface-based role surface is defined as making it\n possible for the surface to be shown by the compositor. Note that\n a mapped surface is not guaranteed to be visible once it is mapped.\n\n For an xdg_surface to be mapped by the compositor, the following\n conditions must be met:\n (1) the client has assigned an xdg_surface-based role to the surface\n (2) the client has set and committed the xdg_surface state and the\n role-dependent state to the surface\n (3) the client has committed a buffer to the surface\n\n A newly-unmapped surface is considered to have met condition (1) out\n of the 3 required conditions for mapping a surface if its role surface\n has not been destroyed, i.e. the client must perform the initial commit\n again before attaching a buffer.\n @section page_iface_xdg_surface_api API\n See @ref iface_xdg_surface.\n/\n/**\n @defgroup iface_xdg_surface The xdg_surface interface\n\n An interface that may be implemented by a wl_surface, for\n implementations that provide a desktop-style user interface.\n\n It provides a base set of functionality required to construct user\n interface elements requiring management by the compositor, such as\n toplevel windows, menus, etc. The types of functionality are split into\n xdg_surface roles.\n\n Creating an xdg_surface does not set the role for a wl_surface. In order\n to map an xdg_surface, the client must create a role-specific object\n using, e.g., get_toplevel, get_popup. The wl_surface for any given\n xdg_surface can have at most one role, and may not be assigned any role\n not based on xdg_surface.\n\n A role must be assigned before any other requests are made to the\n xdg_surface object.\n\n The client must call wl_surface.commit on the corresponding wl_surface\n for the xdg_surface state to take effect.\n\n Creating an xdg_surface from a wl_surface which has a buffer attached or\n committed is a client error, and any attempts by a client to attach or\n manipulate a buffer prior to the first xdg_surface.configure call must\n also be treated as errors.\n\n After creating a role-specific object and setting it up, the client must\n perform an initial commit without any buffer attached. The compositor\n will reply with initial wl_surface state such as\n wl_surface.preferred_buffer_scale followed by an xdg_surface.configure\n event. The client must acknowledge it and is then allowed to attach a\n buffer to map the surface.\n\n Mapping an xdg_surface-based role surface is defined as making it\n possible for the surface to be shown by the compositor. Note that\n a mapped surface is not guaranteed to be visible once it is mapped.\n\n For an xdg_surface to be mapped by the compositor, the following\n conditions must be met:\n (1) the client has assigned an xdg_surface-based role to the surface\n (2) the client has set and committed the xdg_surface state and the\n role-dependent state to the surface\n (3) the client has committed a buffer to the surface\n\n A newly-unmapped surface is considered to have met condition (1) out\n of the 3 required conditions for mapping a surface if its role surface\n has not been destroyed, i.e. the client must perform the initial commit\n again before attaching a buffer."]
    pub static xdg_surface_interface: wl_interface;
}
extern "C" {
    #[doc = " @page page_iface_xdg_toplevel xdg_toplevel\n @section page_iface_xdg_toplevel_desc Description\n\n This interface defines an xdg_surface role which allows a surface to,\n among other things, set window-like properties such as maximize,\n fullscreen, and minimize, set application-specific metadata like title and\n id, and well as trigger user interactive operations such as interactive\n resize and move.\n\n A xdg_toplevel by default is responsible for providing the full intended\n visual representation of the toplevel, which depending on the window\n state, may mean things like a title bar, window controls and drop shadow.\n\n Unmapping an xdg_toplevel means that the surface cannot be shown\n by the compositor until it is explicitly mapped again.\n All active operations (e.g., move, resize) are canceled and all\n attributes (e.g. title, state, stacking, ...) are discarded for\n an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to\n the state it had right after xdg_surface.get_toplevel. The client\n can re-map the toplevel by perfoming a commit without any buffer\n attached, waiting for a configure event and handling it as usual (see\n xdg_surface description).\n\n Attaching a null buffer to a toplevel unmaps the surface.\n @section page_iface_xdg_toplevel_api API\n See @ref iface_xdg_toplevel.\n/\n/**\n @defgroup iface_xdg_toplevel The xdg_toplevel interface\n\n This interface defines an xdg_surface role which allows a surface to,\n among other things, set window-like properties such as maximize,\n fullscreen, and minimize, set application-specific metadata like title and\n id, and well as trigger user interactive operations such as interactive\n resize and move.\n\n A xdg_toplevel by default is responsible for providing the full intended\n visual representation of the toplevel, which depending on the window\n state, may mean things like a title bar, window controls and drop shadow.\n\n Unmapping an xdg_toplevel means that the surface cannot be shown\n by the compositor until it is explicitly mapped again.\n All active operations (e.g., move, resize) are canceled and all\n attributes (e.g. title, state, stacking, ...) are discarded for\n an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to\n the state it had right after xdg_surface.get_toplevel. The client\n can re-map the toplevel by perfoming a commit without any buffer\n attached, waiting for a configure event and handling it as usual (see\n xdg_surface description).\n\n Attaching a null buffer to a toplevel unmaps the surface."]
    pub static xdg_toplevel_interface: wl_interface;
}
 extern "C" {
     #[doc = " @page page_iface_xdg_popup xdg_popup\n @section page_iface_xdg_popup_desc Description\n\n A popup surface is a short-lived, temporary surface. It can be used to\n implement for example menus, popovers, tooltips and other similar user\n interface concepts.\n\n A popup can be made to take an explicit grab. See xdg_popup.grab for\n details.\n\n When the popup is dismissed, a popup_done event will be sent out, and at\n the same time the surface will be unmapped. See the xdg_popup.popup_done\n event for details.\n\n Explicitly destroying the xdg_popup object will also dismiss the popup and\n unmap the surface. Clients that want to dismiss the popup when another\n surface of their own is clicked should dismiss the popup using the destroy\n request.\n\n A newly created xdg_popup will be stacked on top of all previously created\n xdg_popup surfaces associated with the same xdg_toplevel.\n\n The parent of an xdg_popup must be mapped (see the xdg_surface\n description) before the xdg_popup itself.\n\n The client must call wl_surface.commit on the corresponding wl_surface\n for the xdg_popup state to take effect.\n @section page_iface_xdg_popup_api API\n See @ref iface_xdg_popup.\n/\n/**\n @defgroup iface_xdg_popup The xdg_popup interface\n\n A popup surface is a short-lived, temporary surface. It can be used to\n implement for example menus, popovers, tooltips and other similar user\n interface concepts.\n\n A popup can be made to take an explicit grab. See xdg_popup.grab for\n details.\n\n When the popup is dismissed, a popup_done event will be sent out, and at\n the same time the surface will be unmapped. See the xdg_popup.popup_done\n event for details.\n\n Explicitly destroying the xdg_popup object will also dismiss the popup and\n unmap the surface. Clients that want to dismiss the popup when another\n surface of their own is clicked should dismiss the popup using the destroy\n request.\n\n A newly created xdg_popup will be stacked on top of all previously created\n xdg_popup surfaces associated with the same xdg_toplevel.\n\n The parent of an xdg_popup must be mapped (see the xdg_surface\n description) before the xdg_popup itself.\n\n The client must call wl_surface.commit on the corresponding wl_surface\n for the xdg_popup state to take effect."]
     pub static xdg_popup_interface: wl_interface;
 }
 #[doc = " given wl_surface has another role"]
 pub const xdg_wm_base_error_XDG_WM_BASE_ERROR_ROLE: xdg_wm_base_error = 0;
 #[doc = " xdg_wm_base was destroyed before children"]
 pub const xdg_wm_base_error_XDG_WM_BASE_ERROR_DEFUNCT_SURFACES: xdg_wm_base_error = 1;
 #[doc = " the client tried to map or destroy a non-topmost popup"]
 pub const xdg_wm_base_error_XDG_WM_BASE_ERROR_NOT_THE_TOPMOST_POPUP: xdg_wm_base_error = 2;
 #[doc = " the client specified an invalid popup parent surface"]
 pub const xdg_wm_base_error_XDG_WM_BASE_ERROR_INVALID_POPUP_PARENT: xdg_wm_base_error = 3;
 #[doc = " the client provided an invalid surface state"]
 pub const xdg_wm_base_error_XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE: xdg_wm_base_error = 4;
 #[doc = " the client provided an invalid positioner"]
 pub const xdg_wm_base_error_XDG_WM_BASE_ERROR_INVALID_POSITIONER: xdg_wm_base_error = 5;
 #[doc = " the client didnt respond to a ping event in time"]
 pub const xdg_wm_base_error_XDG_WM_BASE_ERROR_UNRESPONSIVE: xdg_wm_base_error = 6;
 pub type xdg_wm_base_error = ::std::os::raw::c_uint;
#[doc = " @ingroup iface_xdg_wm_base\n @struct xdg_wm_base_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdg_wm_base_listener {
    #[doc = " check if the client is alive\n\n The ping event asks the client if it's still alive. Pass the\n serial specified in the event back to the compositor by sending\n a \"pong\" request back with the specified serial. See\n xdg_wm_base.pong.\n\n Compositors can use this to determine if the client is still\n alive. It's unspecified what will happen if the client doesn't\n respond to the ping request, or in what timeframe. Clients\n should try to respond in a reasonable amount of time. The\n unresponsive error is provided for compositors that wish\n to disconnect unresponsive clients.\n\n A compositor is free to ping in any way it wants, but a client\n must always respond to any xdg_wm_base object it created.\n @param serial pass this to the pong request"]
    pub ping: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            xdg_wm_base: *mut xdg_wm_base,
            serial: u32,
        ),
    >,
}
 #[test]
 fn bindgen_test_layout_xdg_wm_base_listener() {
     const UNINIT: ::std::mem::MaybeUninit<xdg_wm_base_listener> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<xdg_wm_base_listener>(),
         8usize,
         concat!("Size of: ", stringify!(xdg_wm_base_listener))
     );
     assert_eq!(
         ::std::mem::align_of::<xdg_wm_base_listener>(),
         8usize,
         concat!("Alignment of ", stringify!(xdg_wm_base_listener))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).ping) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(xdg_wm_base_listener),
             "::",
             stringify!(ping)
         )
     );
 }
 #[doc = " invalid input provided"]
 pub const xdg_positioner_error_XDG_POSITIONER_ERROR_INVALID_INPUT: xdg_positioner_error = 0;
 pub type xdg_positioner_error = ::std::os::raw::c_uint;
 pub const xdg_positioner_anchor_XDG_POSITIONER_ANCHOR_NONE: xdg_positioner_anchor = 0;
 pub const xdg_positioner_anchor_XDG_POSITIONER_ANCHOR_TOP: xdg_positioner_anchor = 1;
 pub const xdg_positioner_anchor_XDG_POSITIONER_ANCHOR_BOTTOM: xdg_positioner_anchor = 2;
 pub const xdg_positioner_anchor_XDG_POSITIONER_ANCHOR_LEFT: xdg_positioner_anchor = 3;
 pub const xdg_positioner_anchor_XDG_POSITIONER_ANCHOR_RIGHT: xdg_positioner_anchor = 4;
 pub const xdg_positioner_anchor_XDG_POSITIONER_ANCHOR_TOP_LEFT: xdg_positioner_anchor = 5;
 pub const xdg_positioner_anchor_XDG_POSITIONER_ANCHOR_BOTTOM_LEFT: xdg_positioner_anchor = 6;
 pub const xdg_positioner_anchor_XDG_POSITIONER_ANCHOR_TOP_RIGHT: xdg_positioner_anchor = 7;
 pub const xdg_positioner_anchor_XDG_POSITIONER_ANCHOR_BOTTOM_RIGHT: xdg_positioner_anchor = 8;
 pub type xdg_positioner_anchor = ::std::os::raw::c_uint;
 pub const xdg_positioner_gravity_XDG_POSITIONER_GRAVITY_NONE: xdg_positioner_gravity = 0;
 pub const xdg_positioner_gravity_XDG_POSITIONER_GRAVITY_TOP: xdg_positioner_gravity = 1;
 pub const xdg_positioner_gravity_XDG_POSITIONER_GRAVITY_BOTTOM: xdg_positioner_gravity = 2;
 pub const xdg_positioner_gravity_XDG_POSITIONER_GRAVITY_LEFT: xdg_positioner_gravity = 3;
 pub const xdg_positioner_gravity_XDG_POSITIONER_GRAVITY_RIGHT: xdg_positioner_gravity = 4;
 pub const xdg_positioner_gravity_XDG_POSITIONER_GRAVITY_TOP_LEFT: xdg_positioner_gravity = 5;
 pub const xdg_positioner_gravity_XDG_POSITIONER_GRAVITY_BOTTOM_LEFT: xdg_positioner_gravity = 6;
 pub const xdg_positioner_gravity_XDG_POSITIONER_GRAVITY_TOP_RIGHT: xdg_positioner_gravity = 7;
 pub const xdg_positioner_gravity_XDG_POSITIONER_GRAVITY_BOTTOM_RIGHT: xdg_positioner_gravity = 8;
 pub type xdg_positioner_gravity = ::std::os::raw::c_uint;
 #[doc = " don't move the child surface when constrained\n\n Don't alter the surface position even if it is constrained on\n some axis, for example partially outside the edge of an output."]
 pub const xdg_positioner_constraint_adjustment_XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_NONE:
     xdg_positioner_constraint_adjustment = 0;
 #[doc = " move along the x axis until unconstrained\n\n Slide the surface along the x axis until it is no longer\n constrained.\n\n First try to slide towards the direction of the gravity on the x\n axis until either the edge in the opposite direction of the\n gravity is unconstrained or the edge in the direction of the\n gravity is constrained.\n\n Then try to slide towards the opposite direction of the gravity\n on the x axis until either the edge in the direction of the\n gravity is unconstrained or the edge in the opposite direction\n of the gravity is constrained."]
 pub const xdg_positioner_constraint_adjustment_XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_X:
     xdg_positioner_constraint_adjustment = 1;
 #[doc = " move along the y axis until unconstrained\n\n Slide the surface along the y axis until it is no longer\n constrained.\n\n First try to slide towards the direction of the gravity on the y\n axis until either the edge in the opposite direction of the\n gravity is unconstrained or the edge in the direction of the\n gravity is constrained.\n\n Then try to slide towards the opposite direction of the gravity\n on the y axis until either the edge in the direction of the\n gravity is unconstrained or the edge in the opposite direction\n of the gravity is constrained."]
 pub const xdg_positioner_constraint_adjustment_XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_Y:
     xdg_positioner_constraint_adjustment = 2;
 #[doc = " invert the anchor and gravity on the x axis\n\n Invert the anchor and gravity on the x axis if the surface is\n constrained on the x axis. For example, if the left edge of the\n surface is constrained, the gravity is 'left' and the anchor is\n 'left', change the gravity to 'right' and the anchor to 'right'.\n\n If the adjusted position also ends up being constrained, the\n resulting position of the flip_x adjustment will be the one\n before the adjustment."]
 pub const xdg_positioner_constraint_adjustment_XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_X:
     xdg_positioner_constraint_adjustment = 4;
 #[doc = " invert the anchor and gravity on the y axis\n\n Invert the anchor and gravity on the y axis if the surface is\n constrained on the y axis. For example, if the bottom edge of\n the surface is constrained, the gravity is 'bottom' and the\n anchor is 'bottom', change the gravity to 'top' and the anchor\n to 'top'.\n\n The adjusted position is calculated given the original anchor\n rectangle and offset, but with the new flipped anchor and\n gravity values.\n\n If the adjusted position also ends up being constrained, the\n resulting position of the flip_y adjustment will be the one\n before the adjustment."]
 pub const xdg_positioner_constraint_adjustment_XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_Y:
     xdg_positioner_constraint_adjustment = 8;
 #[doc = " horizontally resize the surface\n\n Resize the surface horizontally so that it is completely\n unconstrained."]
 pub const xdg_positioner_constraint_adjustment_XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_X:
     xdg_positioner_constraint_adjustment = 16;
 #[doc = " vertically resize the surface\n\n Resize the surface vertically so that it is completely\n unconstrained."]
 pub const xdg_positioner_constraint_adjustment_XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_Y:
     xdg_positioner_constraint_adjustment = 32;
 #[doc = " @ingroup iface_xdg_positioner\n constraint adjustments\n\n The constraint adjustment value define ways the compositor will adjust\n the position of the surface, if the unadjusted position would result\n in the surface being partly constrained.\n\n Whether a surface is considered 'constrained' is left to the compositor\n to determine. For example, the surface may be partly outside the\n compositor's defined 'work area', thus necessitating the child surface's\n position be adjusted until it is entirely inside the work area.\n\n The adjustments can be combined, according to a defined precedence: 1)\n Flip, 2) Slide, 3) Resize."]
 pub type xdg_positioner_constraint_adjustment = ::std::os::raw::c_uint;
 #[doc = " Surface was not fully constructed"]
 pub const xdg_surface_error_XDG_SURFACE_ERROR_NOT_CONSTRUCTED: xdg_surface_error = 1;
 #[doc = " Surface was already constructed"]
 pub const xdg_surface_error_XDG_SURFACE_ERROR_ALREADY_CONSTRUCTED: xdg_surface_error = 2;
 #[doc = " Attaching a buffer to an unconfigured surface"]
 pub const xdg_surface_error_XDG_SURFACE_ERROR_UNCONFIGURED_BUFFER: xdg_surface_error = 3;
 #[doc = " Invalid serial number when acking a configure event"]
 pub const xdg_surface_error_XDG_SURFACE_ERROR_INVALID_SERIAL: xdg_surface_error = 4;
 #[doc = " Width or height was zero or negative"]
 pub const xdg_surface_error_XDG_SURFACE_ERROR_INVALID_SIZE: xdg_surface_error = 5;
 #[doc = " Surface was destroyed before its role object"]
 pub const xdg_surface_error_XDG_SURFACE_ERROR_DEFUNCT_ROLE_OBJECT: xdg_surface_error = 6;
 pub type xdg_surface_error = ::std::os::raw::c_uint;
#[doc = " @ingroup iface_xdg_surface\n @struct xdg_surface_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdg_surface_listener {
    #[doc = " suggest a surface change\n\n The configure event marks the end of a configure sequence. A\n configure sequence is a set of one or more events configuring\n the state of the xdg_surface, including the final\n xdg_surface.configure event.\n\n Where applicable, xdg_surface surface roles will during a\n configure sequence extend this event as a latched state sent as\n events before the xdg_surface.configure event. Such events\n should be considered to make up a set of atomically applied\n configuration states, where the xdg_surface.configure commits\n the accumulated state.\n\n Clients should arrange their surface for the new states, and\n then send an ack_configure request with the serial sent in this\n configure event at some point before committing the new surface.\n\n If the client receives multiple configure events before it can\n respond to one, it is free to discard all but the last event it\n received.\n @param serial serial of the configure event"]
    pub configure: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            xdg_surface: *mut xdg_surface,
            serial: u32,
        ),
    >,
}
 #[test]
 fn bindgen_test_layout_xdg_surface_listener() {
     const UNINIT: ::std::mem::MaybeUninit<xdg_surface_listener> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<xdg_surface_listener>(),
         8usize,
         concat!("Size of: ", stringify!(xdg_surface_listener))
     );
     assert_eq!(
         ::std::mem::align_of::<xdg_surface_listener>(),
         8usize,
         concat!("Alignment of ", stringify!(xdg_surface_listener))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).configure) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(xdg_surface_listener),
             "::",
             stringify!(configure)
         )
     );
 }
 #[doc = " provided value is         not a valid variant of the resize_edge enum"]
 pub const xdg_toplevel_error_XDG_TOPLEVEL_ERROR_INVALID_RESIZE_EDGE: xdg_toplevel_error = 0;
 #[doc = " invalid parent toplevel"]
 pub const xdg_toplevel_error_XDG_TOPLEVEL_ERROR_INVALID_PARENT: xdg_toplevel_error = 1;
 #[doc = " client provided an invalid min or max size"]
 pub const xdg_toplevel_error_XDG_TOPLEVEL_ERROR_INVALID_SIZE: xdg_toplevel_error = 2;
 pub type xdg_toplevel_error = ::std::os::raw::c_uint;
 pub const xdg_toplevel_resize_edge_XDG_TOPLEVEL_RESIZE_EDGE_NONE: xdg_toplevel_resize_edge = 0;
 pub const xdg_toplevel_resize_edge_XDG_TOPLEVEL_RESIZE_EDGE_TOP: xdg_toplevel_resize_edge = 1;
 pub const xdg_toplevel_resize_edge_XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM: xdg_toplevel_resize_edge = 2;
 pub const xdg_toplevel_resize_edge_XDG_TOPLEVEL_RESIZE_EDGE_LEFT: xdg_toplevel_resize_edge = 4;
 pub const xdg_toplevel_resize_edge_XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT: xdg_toplevel_resize_edge = 5;
 pub const xdg_toplevel_resize_edge_XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT: xdg_toplevel_resize_edge =
     6;
 pub const xdg_toplevel_resize_edge_XDG_TOPLEVEL_RESIZE_EDGE_RIGHT: xdg_toplevel_resize_edge = 8;
 pub const xdg_toplevel_resize_edge_XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT: xdg_toplevel_resize_edge = 9;
 pub const xdg_toplevel_resize_edge_XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT: xdg_toplevel_resize_edge =
     10;
 #[doc = " @ingroup iface_xdg_toplevel\n edge values for resizing\n\n These values are used to indicate which edge of a surface\n is being dragged in a resize operation."]
 pub type xdg_toplevel_resize_edge = ::std::os::raw::c_uint;
 #[doc = " the surface is maximized\n the surface is maximized\n\n The surface is maximized. The window geometry specified in the\n configure event must be obeyed by the client, or the\n xdg_wm_base.invalid_surface_state error is raised.\n\n The client should draw without shadow or other decoration\n outside of the window geometry."]
 pub const xdg_toplevel_state_XDG_TOPLEVEL_STATE_MAXIMIZED: xdg_toplevel_state = 1;
 #[doc = " the surface is fullscreen\n the surface is fullscreen\n\n The surface is fullscreen. The window geometry specified in\n the configure event is a maximum; the client cannot resize\n beyond it. For a surface to cover the whole fullscreened area,\n the geometry dimensions must be obeyed by the client. For more\n details, see xdg_toplevel.set_fullscreen."]
 pub const xdg_toplevel_state_XDG_TOPLEVEL_STATE_FULLSCREEN: xdg_toplevel_state = 2;
 #[doc = " the surface is being resized\n the surface is being resized\n\n The surface is being resized. The window geometry specified in\n the configure event is a maximum; the client cannot resize\n beyond it. Clients that have aspect ratio or cell sizing\n configuration can use a smaller size, however."]
 pub const xdg_toplevel_state_XDG_TOPLEVEL_STATE_RESIZING: xdg_toplevel_state = 3;
 #[doc = " the surface is now activated\n the surface is now activated\n\n Client window decorations should be painted as if the window\n is active. Do not assume this means that the window actually has\n keyboard or pointer focus."]
 pub const xdg_toplevel_state_XDG_TOPLEVEL_STATE_ACTIVATED: xdg_toplevel_state = 4;
 #[doc = " the surfaces left edge is tiled\n\n The window is currently in a tiled layout and the left edge is\n considered to be adjacent to another part of the tiling grid.\n @since 2"]
 pub const xdg_toplevel_state_XDG_TOPLEVEL_STATE_TILED_LEFT: xdg_toplevel_state = 5;
 #[doc = " the surfaces right edge is tiled\n\n The window is currently in a tiled layout and the right edge\n is considered to be adjacent to another part of the tiling grid.\n @since 2"]
 pub const xdg_toplevel_state_XDG_TOPLEVEL_STATE_TILED_RIGHT: xdg_toplevel_state = 6;
 #[doc = " the surfaces top edge is tiled\n\n The window is currently in a tiled layout and the top edge is\n considered to be adjacent to another part of the tiling grid.\n @since 2"]
 pub const xdg_toplevel_state_XDG_TOPLEVEL_STATE_TILED_TOP: xdg_toplevel_state = 7;
 #[doc = " the surfaces bottom edge is tiled\n\n The window is currently in a tiled layout and the bottom edge\n is considered to be adjacent to another part of the tiling grid.\n @since 2"]
 pub const xdg_toplevel_state_XDG_TOPLEVEL_STATE_TILED_BOTTOM: xdg_toplevel_state = 8;
 #[doc = " surface repaint is suspended\n\n The surface is currently not ordinarily being repainted; for\n example because its content is occluded by another window, or\n its outputs are switched off due to screen locking.\n @since 6"]
 pub const xdg_toplevel_state_XDG_TOPLEVEL_STATE_SUSPENDED: xdg_toplevel_state = 9;
 #[doc = " @ingroup iface_xdg_toplevel\n types of state on the surface\n\n The different state values used on the surface. This is designed for\n state values like maximized, fullscreen. It is paired with the\n configure event to ensure that both the client and the compositor\n setting the state can be synchronized.\n\n States set in this way are double-buffered. They will get applied on\n the next commit."]
 pub type xdg_toplevel_state = ::std::os::raw::c_uint;
 #[doc = " show_window_menu is available"]
 pub const xdg_toplevel_wm_capabilities_XDG_TOPLEVEL_WM_CAPABILITIES_WINDOW_MENU:
     xdg_toplevel_wm_capabilities = 1;
 #[doc = " set_maximized and unset_maximized are available"]
 pub const xdg_toplevel_wm_capabilities_XDG_TOPLEVEL_WM_CAPABILITIES_MAXIMIZE:
     xdg_toplevel_wm_capabilities = 2;
 #[doc = " set_fullscreen and unset_fullscreen are available"]
 pub const xdg_toplevel_wm_capabilities_XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN:
     xdg_toplevel_wm_capabilities = 3;
 #[doc = " set_minimized is available"]
 pub const xdg_toplevel_wm_capabilities_XDG_TOPLEVEL_WM_CAPABILITIES_MINIMIZE:
     xdg_toplevel_wm_capabilities = 4;
 pub type xdg_toplevel_wm_capabilities = ::std::os::raw::c_uint;
#[doc = " @ingroup iface_xdg_toplevel\n @struct xdg_toplevel_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdg_toplevel_listener {
    #[doc = " suggest a surface change\n\n This configure event asks the client to resize its toplevel\n surface or to change its state. The configured state should not\n be applied immediately. See xdg_surface.configure for details.\n\n The width and height arguments specify a hint to the window\n about how its surface should be resized in window geometry\n coordinates. See set_window_geometry.\n\n If the width or height arguments are zero, it means the client\n should decide its own window dimension. This may happen when the\n compositor needs to configure the state of the surface but\n doesn't have any information about any previous or expected\n dimension.\n\n The states listed in the event specify how the width/height\n arguments should be interpreted, and possibly how it should be\n drawn.\n\n Clients must send an ack_configure in response to this event.\n See xdg_surface.configure and xdg_surface.ack_configure for\n details."]
    pub configure: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            xdg_toplevel: *mut xdg_toplevel,
            width: i32,
            height: i32,
            states: *mut wl_array,
        ),
    >,
    #[doc = " surface wants to be closed\n\n The close event is sent by the compositor when the user wants\n the surface to be closed. This should be equivalent to the user\n clicking the close button in client-side decorations, if your\n application has any.\n\n This is only a request that the user intends to close the\n window. The client may choose to ignore this request, or show a\n dialog to ask the user to save their data, etc."]
    pub close: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, xdg_toplevel: *mut xdg_toplevel),
    >,
    #[doc = " recommended window geometry bounds\n\n The configure_bounds event may be sent prior to a\n xdg_toplevel.configure event to communicate the bounds a window\n geometry size is recommended to constrain to.\n\n The passed width and height are in surface coordinate space. If\n width and height are 0, it means bounds is unknown and\n equivalent to as if no configure_bounds event was ever sent for\n this surface.\n\n The bounds can for example correspond to the size of a monitor\n excluding any panels or other shell components, so that a\n surface isn't created in a way that it cannot fit.\n\n The bounds may change at any point, and in such a case, a new\n xdg_toplevel.configure_bounds will be sent, followed by\n xdg_toplevel.configure and xdg_surface.configure.\n @since 4"]
    pub configure_bounds: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            xdg_toplevel: *mut xdg_toplevel,
            width: i32,
            height: i32,
        ),
    >,
    #[doc = " compositor capabilities\n\n This event advertises the capabilities supported by the\n compositor. If a capability isn't supported, clients should hide\n or disable the UI elements that expose this functionality. For\n instance, if the compositor doesn't advertise support for\n minimized toplevels, a button triggering the set_minimized\n request should not be displayed.\n\n The compositor will ignore requests it doesn't support. For\n instance, a compositor which doesn't advertise support for\n minimized will ignore set_minimized requests.\n\n Compositors must send this event once before the first\n xdg_surface.configure event. When the capabilities change,\n compositors must send this event again and then send an\n xdg_surface.configure event.\n\n The configured state should not be applied immediately. See\n xdg_surface.configure for details.\n\n The capabilities are sent as an array of 32-bit unsigned\n integers in native endianness.\n @param capabilities array of 32-bit capabilities\n @since 5"]
    pub wm_capabilities: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            xdg_toplevel: *mut xdg_toplevel,
            capabilities: *mut wl_array,
        ),
    >,
}
 #[test]
 fn bindgen_test_layout_xdg_toplevel_listener() {
     const UNINIT: ::std::mem::MaybeUninit<xdg_toplevel_listener> =
         ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<xdg_toplevel_listener>(),
         32usize,
         concat!("Size of: ", stringify!(xdg_toplevel_listener))
     );
     assert_eq!(
         ::std::mem::align_of::<xdg_toplevel_listener>(),
         8usize,
         concat!("Alignment of ", stringify!(xdg_toplevel_listener))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).configure) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(xdg_toplevel_listener),
             "::",
             stringify!(configure)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(xdg_toplevel_listener),
             "::",
             stringify!(close)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).configure_bounds) as usize - ptr as usize },
         16usize,
         concat!(
             "Offset of field: ",
             stringify!(xdg_toplevel_listener),
             "::",
             stringify!(configure_bounds)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).wm_capabilities) as usize - ptr as usize },
         24usize,
         concat!(
             "Offset of field: ",
             stringify!(xdg_toplevel_listener),
             "::",
             stringify!(wm_capabilities)
         )
     );
 }
 #[doc = " tried to grab after being mapped"]
 pub const xdg_popup_error_XDG_POPUP_ERROR_INVALID_GRAB: xdg_popup_error = 0;
 pub type xdg_popup_error = ::std::os::raw::c_uint;
 #[doc = " @ingroup iface_xdg_popup\n @struct xdg_popup_listener"]
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct xdg_popup_listener {
     #[doc = " configure the popup surface\n\n This event asks the popup surface to configure itself given\n the configuration. The configured state should not be applied\n immediately. See xdg_surface.configure for details.\n\n The x and y arguments represent the position the popup was\n placed at given the xdg_positioner rule, relative to the upper\n left corner of the window geometry of the parent surface.\n\n For version 2 or older, the configure event for an xdg_popup is\n only ever sent once for the initial configuration. Starting with\n version 3, it may be sent again if the popup is setup with an\n xdg_positioner with set_reactive requested, or in response to\n xdg_popup.reposition requests.\n @param x x position relative to parent surface window geometry\n @param y y position relative to parent surface window geometry\n @param width window geometry width\n @param height window geometry height"]
     pub configure: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             xdg_popup: *mut xdg_popup,
             x: i32,
             y: i32,
             width: i32,
             height: i32,
         ),
     >,
     #[doc = " popup interaction is done\n\n The popup_done event is sent out when a popup is dismissed by\n the compositor. The client should destroy the xdg_popup object\n at this point."]
     pub popup_done: ::std::option::Option<
         unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, xdg_popup: *mut xdg_popup),
     >,
     #[doc = " signal the completion of a repositioned request\n\n The repositioned event is sent as part of a popup\n configuration sequence, together with xdg_popup.configure and\n lastly xdg_surface.configure to notify the completion of a\n reposition request.\n\n The repositioned event is to notify about the completion of a\n xdg_popup.reposition request. The token argument is the token\n passed in the xdg_popup.reposition request.\n\n Immediately after this event is emitted, xdg_popup.configure and\n xdg_surface.configure will be sent with the updated size and\n position, as well as a new configure serial.\n\n The client should optionally update the content of the popup,\n but must acknowledge the new popup configuration for the new\n position to take effect. See xdg_surface.ack_configure for\n details.\n @param token reposition request token\n @since 3"]
     pub repositioned: ::std::option::Option<
         unsafe extern "C" fn(
             data: *mut ::std::os::raw::c_void,
             xdg_popup: *mut xdg_popup,
             token: u32,
         ),
     >,
 }
 #[test]
 fn bindgen_test_layout_xdg_popup_listener() {
     const UNINIT: ::std::mem::MaybeUninit<xdg_popup_listener> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<xdg_popup_listener>(),
         24usize,
         concat!("Size of: ", stringify!(xdg_popup_listener))
     );
     assert_eq!(
         ::std::mem::align_of::<xdg_popup_listener>(),
         8usize,
         concat!("Alignment of ", stringify!(xdg_popup_listener))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).configure) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(xdg_popup_listener),
             "::",
             stringify!(configure)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).popup_done) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(xdg_popup_listener),
             "::",
             stringify!(popup_done)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).repositioned) as usize - ptr as usize },
         16usize,
         concat!(
             "Offset of field: ",
             stringify!(xdg_popup_listener),
             "::",
             stringify!(repositioned)
         )
     );
 }
 pub type __builtin_va_list = [__va_list_tag; 1usize];
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct __va_list_tag {
     pub gp_offset: ::std::os::raw::c_uint,
     pub fp_offset: ::std::os::raw::c_uint,
     pub overflow_arg_area: *mut ::std::os::raw::c_void,
     pub reg_save_area: *mut ::std::os::raw::c_void,
 }
 #[test]
 fn bindgen_test_layout___va_list_tag() {
     const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
     let ptr = UNINIT.as_ptr();
     assert_eq!(
         ::std::mem::size_of::<__va_list_tag>(),
         24usize,
         concat!("Size of: ", stringify!(__va_list_tag))
     );
     assert_eq!(
         ::std::mem::align_of::<__va_list_tag>(),
         8usize,
         concat!("Alignment of ", stringify!(__va_list_tag))
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
         0usize,
         concat!(
             "Offset of field: ",
             stringify!(__va_list_tag),
             "::",
             stringify!(gp_offset)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
         4usize,
         concat!(
             "Offset of field: ",
             stringify!(__va_list_tag),
             "::",
             stringify!(fp_offset)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
         8usize,
         concat!(
             "Offset of field: ",
             stringify!(__va_list_tag),
             "::",
             stringify!(overflow_arg_area)
         )
     );
     assert_eq!(
         unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
         16usize,
         concat!(
             "Offset of field: ",
             stringify!(__va_list_tag),
             "::",
             stringify!(reg_save_area)
         )
     );
 }
